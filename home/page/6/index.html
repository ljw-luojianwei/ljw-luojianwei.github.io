<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;luojianwei.top&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Gemini&quot;,&quot;version&quot;:&quot;8.5.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:false,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:false,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:true,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;搜索...&quot;,&quot;empty&quot;:&quot;没有找到任何搜索结果：${query}&quot;,&quot;hits_time&quot;:&quot;找到 ${hits} 个搜索结果（用时 ${time} 毫秒）&quot;,&quot;hits&quot;:&quot;找到 ${hits} 个搜索结果&quot;}}</script><script src="/js/config.js"></script>
<meta property="og:type" content="website">
<meta property="og:title" content="罗建伟的个人主页">
<meta property="og:url" content="https://luojianwei.top/home/page/6/index.html">
<meta property="og:site_name" content="罗建伟的个人主页">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="罗建伟的个人博客">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://luojianwei.top/home/page/6/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:true,&quot;isPost&quot;:false,&quot;lang&quot;:&quot;zh-CN&quot;,&quot;comments&quot;:&quot;&quot;,&quot;permalink&quot;:&quot;&quot;,&quot;path&quot;:&quot;home&#x2F;page&#x2F;6&#x2F;index.html&quot;,&quot;title&quot;:&quot;&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>罗建伟的个人主页</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">罗建伟的个人主页</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">明确自己的内心所求，才能更好地解决问题</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/home/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">罗建伟的个人博客</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">68</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://luojianwei.top/2021/06/17/Android-%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E4%B9%8B%E4%B8%80-Android%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="罗建伟的个人博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="罗建伟的个人主页">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/17/Android-%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E4%B9%8B%E4%B8%80-Android%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/" class="post-title-link" itemprop="url">Android 系统启动之一 Android系统架构概述</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-06-17 17:16:21" itemprop="dateCreated datePublished" datetime="2021-06-17T17:16:21+08:00">2021-06-17</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-07-13 18:16:18" itemprop="dateModified" datetime="2021-07-13T18:16:18+08:00">2021-07-13</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/System/" itemprop="url" rel="index"><span itemprop="name">System</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p style="text-indent:2em">本文主要介绍Android的系统架构，Android使用linux内核(Marco kernel)，但是Android的架构又与Linux系统有所不同，因此在介绍Android系统架构之前，我们先一起来了解一下Linux系统的架构。 Linux架构如下图所示：</p>

<p><img src="/.top//linux%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84.jpg" alt="img"></p>
<ul>
<li>Computer Resources：硬件资源</li>
<li>Kernel：内核</li>
<li>Shell：shell是系统的用户界面，提供了用户与内核进行交互操作的一种接口。它接收用户输入的命令并把它送入内核去执行，是一个命令解释器</li>
<li>Programs/Utilities/Tools：库函数、工具等</li>
<li>File systems：文件系统是文件存放在磁盘等存储设备上的组织方法。Linux系统能支持多种目前流行的文件系统，如EXT2、 EXT3、EXT4、 FAT、 FAT32、 VFAT和ISO9660。</li>
<li>User Application: Linux应用，标准的Linux系统一般都有一套被称为应用程序的程序集，它包括文本编辑器、编程语言、X Window、办公套件、Internet工具和数据库等。</li>
</ul>
<p style="text-indent:2em">Linux系统一般由4个组成部分：内核Kernel、Shell、文件系统和应用程序。内核、shell和文件系统一起组成了基本的操作系统结构，它们让用户可以管理文件、运行程序并使用系统。Linux开机后，内核启动，激活内核空间，抽象硬件、初始化硬件参数等，运行并维护虚拟内存、调度器、信号及进程间通信(IPC)。内核启动后，再加载Shell和用户应用程序，用户应用程序使用C\C++编写，被编译成机器码，形成一个进程，通过系统调用(Syscall)与内核系统进行联通。进程间交流需要使用特殊的进程间通信(IPC)机制。</p>

<p style="text-indent:2em">了解了Linux架构，我们再来看看Android系统架构。Android的系统非常庞大且错综复杂，需要具备全面的技术栈，但整体架构设计清晰，底层以Linux内核为基础。Android底层内核空间以Linux Kernel作为基石，上层用户空间由Native系统库、虚拟机运行环境、框架层组成，通过系统调用(Syscall)连通系统的内核空间与用户空间。对于用户空间主要采用C++和Java代码编写，通过JNI技术打通用户空间的Java层和Native层(C++/C)，从而连通整个系统。为了能让大家整体上大致了解Android系统涉及的知识层面，先来看一张Google提供经典Android架构图，从上往下依次为应用层(System Apps)、应用框架层(Java API Framework)、运行层(系统Native库和Android运行时环境)、硬件抽象层(HAL)、Liunx 内核(Marco Kernel)，其中每一层都包含大量的子模块或子系统。</p>

<p><img src="/.top//android%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%A0%86%E6%A0%88.jpg" alt="img"></p>
<ul>
<li>应用层(System Apps) 该层中包含所有的Android应用程序，包括电话、相机、日历等，我们自己开发的Android应用程序也被安装在这层；大部分的应用使用JAVA开发，现在Google也开始力推kotlin进行开发。</li>
<li>应用框架层(Java API Framework)这一层主要提供构建应用程序时可能用到的各种API，Android自带的一些核心应用就是使用这些API完成的，开发者也可以通过使用API来构建自己的应用程序。</li>
<li>运行层<ul>
<li>系统Native库    Android包含一些C/C++库，这些库能被Android系统中不同的组件使用</li>
<li>Android运行时环境    Android包括了一个核心库，该核心库提供了Java编程语言核心库的大多数功能。虚拟机也在该层启动。每个Android应用都有一个专有的进程，这些进程每个都有一个Dalivik虚拟机实例，并在该实例中运行。</li>
</ul>
</li>
<li>硬件抽象层(HAL) Android的硬件驱动与Linux不同，传统的Liunx内核驱动完全存在于内核空间中。但是Android在内核外部增加了一个硬件抽象层(HAL,Hardware Abstraction Layer)，把一部分硬件驱动放到了HAL层。为什么Android要这么做呢？Linux内核采用了GPL协议，如果硬件厂商需要支持Linux系统，就需要遵照GPL协议公开硬件驱动的源代码，这势必会影响到硬件厂家的核心利益。Android的HAL层运行在用户空间，HAL是一个“空壳”，Android会根据不同的需要，加载不同的动态库。这些动态库由硬件厂家提供。硬件厂家把相关硬件功能写入动态库，内核中只开放一些基本的读写接口操作。这样一些硬件厂家的驱动功能就由内核空间移动到了用户空间。Android的HAL层遵循Apache协议，并不要求它的配套程序，因此厂家提供的驱动库不需要进行开放，保护了硬件厂家的核心利益。</li>
<li>Linux Kernel Android平台的基础是Linux内核，比如ART虚拟机最终调用底层Linux内核来执行功能。Linux内核的安全机制为Android提供相应的保障，也允许设备制造商为内核开发硬件驱动程序。</li>
</ul>
<p style="text-indent:2em">上图采用静态分层方式的架构划分，众所周知，程序代码是死的，系统运转是活的，各模块代码运行在不同的进程(线程)中，相互之间进行着各种错终复杂的信息传递与交互流，从这个角度来说此图并没能体现Android整个系统的内部架构、运行机理，以及各个模块之间是如何衔接与配合工作的。为了更深入地掌握Android整个架构思想以及各个模块在Android系统所处的地位与价值，计划以Android系统启动过程为主线，以进程的视角来诠释Android系统全貌，全方位的深度剖析各个模块功能，争取各个击破。这样才能犹如庖丁解牛，解决、分析问题则能游刃有余。</p>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://luojianwei.top/2021/06/17/Android-%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E4%B9%8B%E9%9B%B6-%E5%BA%8F%E8%A8%80%E5%92%8C%E7%9B%AE%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="罗建伟的个人博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="罗建伟的个人主页">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/17/Android-%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E4%B9%8B%E9%9B%B6-%E5%BA%8F%E8%A8%80%E5%92%8C%E7%9B%AE%E5%BD%95/" class="post-title-link" itemprop="url">Android 系统启动之零 序言和目录</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-06-17 17:11:02" itemprop="dateCreated datePublished" datetime="2021-06-17T17:11:02+08:00">2021-06-17</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-07-13 18:16:18" itemprop="dateModified" datetime="2021-07-13T18:16:18+08:00">2021-07-13</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/System/" itemprop="url" rel="index"><span itemprop="name">System</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://ljw-luojianwei.github.io/2021/06/17/Android-%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E4%B9%8B%E9%9B%B6-%E5%BA%8F%E8%A8%80%E5%92%8C%E7%9B%AE%E5%BD%95">00.目录</a><br><a target="_blank" rel="noopener" href="https://ljw-luojianwei.github.io/2021/06/17/Android-%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E4%B9%8B%E4%B8%80-Android%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/">01.Android系统架构</a><br><a target="_blank" rel="noopener" href="https://ljw-luojianwei.github.io/2021/06/17/Android-%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E4%B9%8B%E4%BA%8C-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E7%AE%80%E8%BF%B0/">02.启动流程简述</a><br><a target="_blank" rel="noopener" href="https://ljw-luojianwei.github.io/2021/06/17/Android-%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E4%B9%8B%E4%B8%89-init%E8%BF%9B%E7%A8%8B/">03.init进程</a><br><a target="_blank" rel="noopener" href="https://ljw-luojianwei.github.io/2021/06/17/Android-%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E4%B9%8B%E5%9B%9B-Zygote%E8%BF%9B%E7%A8%8B/">04.Zygote进程</a><br><a target="_blank" rel="noopener" href="https://ljw-luojianwei.github.io/2021/06/17/Android-%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E4%B9%8B%E4%BA%94-SystemServer%E8%BF%9B%E7%A8%8B/">05.SystemServer进程</a><br><a target="_blank" rel="noopener" href="https://ljw-luojianwei.github.io/2021/06/17/Android-%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E4%B9%8B%E5%85%AD-ActivityMnagerService/">06.ActivityMnagerService</a><br><a target="_blank" rel="noopener" href="https://ljw-luojianwei.github.io/2021/06/17/Android-%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E4%B9%8B%E4%B8%83-Launcher-%E6%A1%8C%E9%9D%A2-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/">07.Launcher(桌面)启动流程</a><br><a target="_blank" rel="noopener" href="https://ljw-luojianwei.github.io/2021/06/17/Android-%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E4%B9%8B%E5%85%AB-%E5%BA%94%E7%94%A8%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%E4%BB%A5%E5%8F%8AZygote%E7%9A%84fork%E6%B5%81%E7%A8%8B/">08.应用进程创建过程以及Zygote的fork流程</a><br><a target="_blank" rel="noopener" href="https://ljw-luojianwei.github.io/2021/06/17/Android-%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E4%B9%8B%E4%B9%9D-PackageManagerService-%E4%B8%80-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/">09.PackageManagerService(一)工作原理及启动流程</a><br><a target="_blank" rel="noopener" href="https://ljw-luojianwei.github.io/2021/06/17/Android-%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E4%B9%8B%E5%8D%81-PackageManagerService-%E4%BA%8C-%E6%9D%83%E9%99%90%E6%89%AB%E6%8F%8F/">10.PackageManagerService(二)权限扫描</a><br><a target="_blank" rel="noopener" href="https://ljw-luojianwei.github.io/2021/06/17/Android-%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E5%8D%81%E4%B8%80-PackageManagerService-%E4%B8%89-APK%E6%89%AB%E6%8F%8F/">11.PackageManagerService(三)APK扫描</a><br><a target="_blank" rel="noopener" href="https://ljw-luojianwei.github.io/2021/06/17/Android-%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E5%8D%81%E4%BA%8C-PackageManagerService-%E5%9B%9B-APK%E5%AE%89%E8%A3%85%E6%B5%81%E7%A8%8B/">12.PackageManagerService(四)APK安装流程</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://luojianwei.top/2021/06/17/Android-%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86%E4%B9%8B%E4%B8%80-AOSP%E9%95%9C%E5%83%8F%E4%B8%8B%E8%BD%BD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="罗建伟的个人博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="罗建伟的个人主页">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/17/Android-%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86%E4%B9%8B%E4%B8%80-AOSP%E9%95%9C%E5%83%8F%E4%B8%8B%E8%BD%BD/" class="post-title-link" itemprop="url">Android 源码管理之一 AOSP镜像下载</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-06-17 11:18:48" itemprop="dateCreated datePublished" datetime="2021-06-17T11:18:48+08:00">2021-06-17</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-06-23 17:59:10" itemprop="dateModified" datetime="2021-06-23T17:59:10+08:00">2021-06-23</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p style="text-indent:2em"><b>关于：</b>&nbsp&nbsp&nbsp&nbsp AOSP(Android Open Source Project)是Google开放的<a target="_blank" rel="noopener" href="https://source.android.google.cn/" style="text-decoration:none">Android开源项目</a>。AOSP通俗来讲就是一个Android系统源码项目，通过它可以定制Android操作系统，国内手机厂商都是在此基础上开发的定制系统。因为墙的缘故，无法连接谷歌服务器获取AOSP源码，就从<a target="_blank" rel="noopener" href="https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/" style="text-decoration:none">清华大学镜像站</a>或者<a target="_blank" rel="noopener" href="https://mirrors.ustc.edu.cn/help/" style="text-decoration:none">中科大镜像</a>。</p>

<p style="text-indent:2em"><b>下载：</b>&nbsp&nbsp&nbsp&nbsp因第一次同步数据量特别大，如果网络不稳定，中间失败就要从头再来了。所以使用镜像站提供的打包的 AOSP 镜像，为一个 tar 包，大约 100G(单文件)，这样就可以通过 HTTP(S) 的方式下载，该方法支持断点续传。初始化 tar 包下载地址：</p>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 清大源，每月更新的初始化包</span></span><br><span class="line">wget -c -t 0 https://mirrors.tuna.tsinghua.edu.cn/aosp-monthly/aosp-latest.tar   <span class="comment"># 使用 wget -c 断点续传进行下载初始化包</span></span><br><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/aosp-monthly/aosp-latest.tar.md5 <span class="comment"># 下载初始化包校验值</span></span><br><span class="line"><span class="comment"># or </span></span><br><span class="line"><span class="comment"># 科大源，定时同步于清大源</span></span><br><span class="line">wget -c -t 0 https://mirrors.ustc.edu.cn/aosp-monthly/aosp-latest.tar</span><br><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/aosp-monthly/aosp-latest.tar.md5</span><br></pre></td></tr></table></figure>

<p style="text-indent:2em"><b>解压：</b>&nbsp&nbsp&nbsp&nbsp下载完成后，根据 checksum 的内容校验一下。接着解压：</p>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar xvf aosp-latest.tar</span><br></pre></td></tr></table></figure>

<p style="text-indent:2em"><b>修改：</b>&nbsp&nbsp&nbsp&nbsp替换已有的 AOSP 源代码的 remote。更改为 
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改 .repo/manifests.git/config</span></span><br><span class="line"><span class="comment"># 将</span></span><br><span class="line">url = https://android.googlesource.com/platform/manifest</span><br><span class="line"><span class="comment"># 更改为清大源</span></span><br><span class="line">url = https://mirrors.tuna.tsinghua.edu.cn/git/AOSP/platform/manifest</span><br><span class="line"><span class="comment"># 或者 科大源</span></span><br><span class="line">url = git://mirrors.ustc.edu.cn/aosp/platform/manifest</span><br><span class="line"><span class="comment"># 如果由于某种原因不能通过 git 协议同步，则可以改为通过 HTTP 协议同步，不推荐使用 HTTP 协议同步，因为 HTTP 服务器不支持 repo sync 的 --depth 选项，可能导致部分仓库同步失败。</span></span><br><span class="line">url = http://mirrors.ustc.edu.cn/aosp/platform/manifest </span><br></pre></td></tr></table></figure>

</p><p style="text-indent:2em"><b>同步：</b>&nbsp&nbsp&nbsp&nbsp由于所有代码都是从隐藏的 .repo 目录中 checkout 出来的，所以 tar 包只保留了 .repo 目录。因此解压后只有一个隐藏的 .repo 目录，需要再 repo sync 一遍可得到完整的目录。由于 AOSP 镜像造成CPU/内存负载过重，镜像站限制了并发数量，因此尽量选择流量较小时错峰同步，sync 的时候并发数不宜太高，否则会出现 503 错误，即-j后面的数字建议选择 4,由于 repo sync 命令默认使用 4 个并发连接，因此勿需使用 -j 参数增加并发连接数。
</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> aosp <span class="comment"># 进入解压得到的 AOSP 工程目录，这时 ls 的话什么也看不到，因为只有一个隐藏的 .repo 目录</span></span><br><span class="line">.repo/repo/repo sync <span class="comment"># 正常同步一遍即可得到完整目录</span></span><br><span class="line"><span class="comment"># 或 </span></span><br><span class="line">.repo/repo/repo sync -l <span class="comment"># 仅checkout代码</span></span><br></pre></td></tr></table></figure>

<p style="text-indent:2em"><b>内核：</b>&nbsp&nbsp&nbsp&nbsp AOSP源码中并不包括内核源码，需要单独下载，内核源码有很多版本，比如common是通用的Linux内核，msm是用于使用高通MSM芯片的Android设备，goldfish是用于Android模拟器的内核源码。</p>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://aosp.tuna.tsinghua.edu.cn/kernel/goldfish.git</span><br><span class="line">git <span class="built_in">clone</span> https://aosp.tuna.tsinghua.edu.cn/kernel/msm.git</span><br></pre></td></tr></table></figure>

<p style="text-indent:2em"><b>工具：</b>&nbsp&nbsp&nbsp&nbsp Android源码包含数百个git库，光是下载这么多的git库就是一项繁重的任务，所以Google开发了<a target="_blank" rel="noopener" href="https://source.android.google.cn/setup/using-repo" style="text-decoration:none">repo</a>，它是用于管理Android版本库的一个工具，使用了Python对git进行了一定的封装，简化了对多个Git版本库的管理。仓库位于：aosp\.repo\repo\.git

</p><p style="text-indent:2em"><b>含义：</b>&nbsp&nbsp&nbsp&nbsp AOSP代码目录含义

<table>
<thead>
<tr>
<th>目录</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>art</td>
<td>全新的ART运行环境，ART虚拟机做为Dalvik虚拟机的替代,字节码翻译优化成机器码从运行时提早到安装,以空间换时间达到更流畅的体验.</td>
</tr>
<tr>
<td>bionic</td>
<td>C/C++运行时库,在NDK程序中很大一部分调用就是这里的程序</td>
</tr>
<tr>
<td>bootable</td>
<td>启动引导相关代码,用于Android装载和启动程序,其中就包括bootloader和recovery.bootloader是Android中唯一在Linux内核之前执行的程序.通过这段程序可以初始化硬件,建立内存控件的映射图等,总之,bootloader就是为Linux内核准备合适的运行环境.</td>
</tr>
<tr>
<td>build</td>
<td>存放系统编译规则及generic等基础开发包配置,用于编译Android源代码以及构建system.img，ramdisk.img等文件的工具.</td>
</tr>
<tr>
<td>compatibility</td>
<td>Android兼容性计划</td>
</tr>
<tr>
<td>cts</td>
<td>Android兼容性测试套件标准</td>
</tr>
<tr>
<td>dalvik</td>
<td>dalvik JAVA虚拟机</td>
</tr>
<tr>
<td>developers</td>
<td>开发者目录,展现了当前版本的新特性</td>
</tr>
<tr>
<td>development</td>
<td>应用程序开发相关,示例以及开发工具 主要是给系统开发者使用</td>
</tr>
<tr>
<td>device</td>
<td>设备相关配置,各品牌手机在硬件上会有差别，厂商会对源码进行定制 修改它的某些部分来配合自家硬件的特性</td>
</tr>
<tr>
<td>external</td>
<td>android使用的一些开源模组相关文件</td>
</tr>
<tr>
<td>frameworks</td>
<td>应用程序核心框架，Android系统核心部分，由Java和C++编写</td>
</tr>
<tr>
<td>hardware</td>
<td>主要是硬件抽象层的代码，部分厂家开源的硬解适配层HAL代码</td>
</tr>
<tr>
<td>kernel</td>
<td>Android Linux 内核，，不过Android默认不提供，需要单独下载</td>
</tr>
<tr>
<td>libcore</td>
<td>Java核心库相关文件，包括java api的源码</td>
</tr>
<tr>
<td>libnativehelper</td>
<td>动态库，实现JNI库的基础</td>
</tr>
<tr>
<td>ndk</td>
<td>NDK相关代码，帮助开发人员在应用程序中嵌入C/C++代码</td>
</tr>
<tr>
<td>out</td>
<td>编译完成后代码输出在此目录</td>
</tr>
<tr>
<td>packages</td>
<td>应用程序包</td>
</tr>
<tr>
<td>pdk</td>
<td>Plug Development Kit 的缩写，本地开发套件，google减小碎片化的东西</td>
</tr>
<tr>
<td>platform_testing</td>
<td>平台测试</td>
</tr>
<tr>
<td>prebuilts</td>
<td>x86和arm架构下预编译好的一些资源，包括模拟器,内核文件</td>
</tr>
<tr>
<td>sdk</td>
<td>在开发环境中使用的工具，如ddms，draw9path，sdkmanager，sdk和模拟器</td>
</tr>
<tr>
<td>system</td>
<td>底层文件系统库、应用和组件 构成 Android的基本系统</td>
</tr>
<tr>
<td>test</td>
<td></td>
</tr>
<tr>
<td>toolchain</td>
<td>工具链文件</td>
</tr>
<tr>
<td>tools</td>
<td>工具文件</td>
</tr>
<tr>
<td>vendor</td>
<td></td>
</tr>
<tr>
<td>Android.bp</td>
<td>Android7.0开始代替Android.mk文件，它是告诉ndk将jni代码编译成动态库的一个脚本</td>
</tr>
<tr>
<td>Makefile</td>
<td>全局Makefile文件，用来定义编译规则</td>
</tr>
</tbody></table>
</p><h5 id="应用层packages部分"><a href="#应用层packages部分" class="headerlink" title="应用层packages部分"></a>应用层packages部分</h5><p>应用层位于整个Android系统的最上层，开发者开发的应用程序以及系统内置的应用程序都是在应用层。源码根目录中的packages目录对应着系统应用层。它的目录结构：</p>
<table>
<thead>
<tr>
<th>packages目录</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>apps</td>
<td>核心应用程序</td>
</tr>
<tr>
<td>experimental</td>
<td>第三方应用程序</td>
</tr>
<tr>
<td>inputmethods</td>
<td>输入法目录</td>
</tr>
<tr>
<td>modules</td>
<td></td>
</tr>
<tr>
<td>providers</td>
<td>内容提供者目录</td>
</tr>
<tr>
<td>screensavers</td>
<td>屏幕保护</td>
</tr>
<tr>
<td>services</td>
<td>通信服务</td>
</tr>
<tr>
<td>wallpapers</td>
<td>墙纸</td>
</tr>
</tbody></table>
<h2 id="应用框架层"><a href="#应用框架层" class="headerlink" title="应用框架层"></a>应用框架层</h2><p>应用框架层是系统的核心部分，一方面向上提供接口给应用层调用，另一方面向下与C/C++程序库以及硬件抽象层等进行衔接。其中目录结构如下：</p>
<ul>
<li>av：多媒体框架</li>
<li>base：Android源码的主要核心目录</li>
<li>compile：编译相关</li>
<li>ex：文件解析器</li>
<li>hardware：硬件适配接口</li>
<li>layoutlib：布局相关</li>
<li>minikin：Android原生字体，连体字效果</li>
<li>ml：机器学习</li>
<li>multidex：多dex加载器</li>
<li>native：native实现</li>
<li>opt：一些软件</li>
<li>rs：Render Script，可创建3D接口</li>
<li>support：framework支持文件</li>
<li>wilhelm：基于Khronos的OpenSL ES/OpenMAX AL的audio/multimedia实现</li>
</ul>
<p>其中base目录中是应用框架层的主要核心代码，目录结构如下：</p>
<ul>
<li>apct-tests：性能优化测试</li>
<li>api：android应用框架层声明类、属性和资源</li>
<li>cmds：android系统启动时用到的commands</li>
<li>core：framework的核心框架组件</li>
<li>data：android下的资源(字体、声音、视频、软盘等)</li>
<li>docs：android项目说明</li>
<li>drm：实现权限管理，数字内容解密等模块的工作</li>
<li>graphics：图像渲染模块</li>
<li>keystore：秘钥库</li>
<li>libs：库信息(界面、存储、USB)</li>
<li>location：位置信息</li>
<li>media：手机媒体管理(音频、视频等)</li>
<li>native：本地方法实现(传感器、输入、界面、窗体)</li>
<li>nfc-extras：近场通讯</li>
<li>obex：蓝牙</li>
<li>opengl：2D和3D图形绘制</li>
<li>packages：框架层的实现(界面、服务、存储)</li>
<li>proto：协议框架</li>
<li>rs：资源框架</li>
<li>samples：例子程序</li>
<li>sax：xml解析器</li>
<li>services：各种服务程序</li>
<li>telecomm：telecomm通信框架</li>
<li>telephony：电话通讯框架</li>
<li>tests：各种测试</li>
<li>vr：虚拟现实相关</li>
<li>wifi：wifi模块</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://luojianwei.top/2021/06/16/Android-Q-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8C-%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%E5%88%9D%E5%A7%8B%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="罗建伟的个人博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="罗建伟的个人主页">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/16/Android-Q-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8C-%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%E5%88%9D%E5%A7%8B%E5%8C%96/" class="post-title-link" itemprop="url">Android Q 编译原理之二 编译环境初始化</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-06-16 16:23:55" itemprop="dateCreated datePublished" datetime="2021-06-16T16:23:55+08:00">2021-06-16</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-06-23 17:59:10" itemprop="dateModified" datetime="2021-06-23T17:59:10+08:00">2021-06-23</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Compiler/" itemprop="url" rel="index"><span itemprop="name">Compiler</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p style="text-indent:2em">上一节针对Android编译系统做了一个笼统的说明，这一节针对编译环境初始化做一下详细的展示。</p>

<h3 id="初始化命令介绍"><a href="#初始化命令介绍" class="headerlink" title="初始化命令介绍"></a>初始化命令介绍</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化命令：</span></span><br><span class="line"><span class="built_in">source</span> build/envsetup.sh</span><br></pre></td></tr></table></figure>

<p style="text-indent:2em">envsetup.sh 构建代码：</p>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...						<span class="comment"># 1</span></span><br><span class="line">validate_current_shell      <span class="comment"># 2</span></span><br><span class="line">source_vendorsetup          <span class="comment"># 3 </span></span><br><span class="line">addcompletions              <span class="comment"># 4</span></span><br></pre></td></tr></table></figure>

<p style="text-indent:2em">envsetup.sh主要做了下面几个事情：</p>

<p><img src="/.top//envsetup.jpg" alt="envsetup"></p>
<h4 id="hmm-查看支持接口"><a href="#hmm-查看支持接口" class="headerlink" title="hmm 查看支持接口"></a>hmm 查看支持接口</h4><p style="text-indent:2em"> 输入hmm可以看到envsetup支持的一些接口：</p>

<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>lunch</td>
<td>lunch <product_name>-<build_variant><br>选择<product_name>作为要构建的产品，<build_variant>作为要构建的变体，并将这些选择存储在环境中，以便后续调用“m”等读取。</build_variant></product_name></build_variant></product_name></td>
</tr>
<tr>
<td>tapas</td>
<td>交互方式：tapas [&amp;ltApp1&amp;gt &amp;ltApp2&amp;gt …] [arm|x86|mips|arm64|x86_64|mips64] [eng|userdebug|user]<br>设置构建解绑定应用程序(APKs)的构建环境。</td>
</tr>
<tr>
<td>banchan</td>
<td>交互方式：banchan &amp;ltmodule1&amp;gt [&amp;ltmodule2&amp;gt …] [arm|x86|arm64|x86_64] [eng|userdebug|user]</td>
</tr>
<tr>
<td>croot</td>
<td>将目录更改到树的顶部或其子目录。</td>
</tr>
<tr>
<td>m</td>
<td>编译整个源码，可以不用切换到根目录</td>
</tr>
<tr>
<td>mm</td>
<td>编译当前目录下的源码，不包含他们的依赖模块</td>
</tr>
<tr>
<td>mmm</td>
<td>编译指定目录下的所有模块，不包含他们的依赖模块.例如：<br>mmm dir/:target1,target2.</td>
</tr>
<tr>
<td>mma</td>
<td>编译当前目录下的源码，包含他们的依赖模块</td>
</tr>
<tr>
<td>mmma</td>
<td>编译指定目录下的所模块，包含他们的依赖模块</td>
</tr>
<tr>
<td>provision</td>
<td>具有所有必需分区的闪存设备。选项将传递给fastboot。</td>
</tr>
<tr>
<td>cgrep</td>
<td>对系统本地所有的C/C++文件执行grep命令</td>
</tr>
<tr>
<td>ggrep</td>
<td>对系统本地所有的Gradle文件执行grep命令</td>
</tr>
<tr>
<td>gogrep</td>
<td>对系统本地所有的Go文件执行grep命令</td>
</tr>
<tr>
<td>jgrep</td>
<td>对系统本地所有的Java文件执行grep命令</td>
</tr>
<tr>
<td>ktgrep</td>
<td>对系统本地所有的Kotlin文件执行grep命令</td>
</tr>
<tr>
<td>resgrep</td>
<td>对系统本地所有的res目录下的xml文件执行grep命令</td>
</tr>
<tr>
<td>mangrep</td>
<td>对系统本地所有的AndroidManifest.xml文件执行grep命令</td>
</tr>
<tr>
<td>mgrep</td>
<td>对系统本地所有的Makefiles文件和*.bp文件执行grep命令</td>
</tr>
<tr>
<td>owngrep</td>
<td>对系统本地所有的OWNERS文件执行grep命令</td>
</tr>
<tr>
<td>rsgrep</td>
<td>对系统本地所有的source文件执行grep命令</td>
</tr>
<tr>
<td>sepgrep</td>
<td>对系统本地所有的Rust文件执行grep命令</td>
</tr>
<tr>
<td>sgrep</td>
<td>对系统本地所有的source文件执行grep命令</td>
</tr>
<tr>
<td>godir</td>
<td>根据godir后的参数文件名在整个目录下查找，并且切换目录</td>
</tr>
<tr>
<td>allmod</td>
<td>列出所有模块</td>
</tr>
<tr>
<td>gomod</td>
<td>转到包含模块的目录</td>
</tr>
<tr>
<td>pathmod</td>
<td>获取包含模块的目录</td>
</tr>
<tr>
<td>outmod</td>
<td>获取具有特定扩展名的模块的已安装输出的位置。</td>
</tr>
<tr>
<td>dirmods</td>
<td>获取在给定目录中定义的模块。</td>
</tr>
<tr>
<td>installmod</td>
<td>Adb安装模块构建的APK。</td>
</tr>
<tr>
<td>refreshmod</td>
<td>刷新allmod/gomod/pathmod/outmod/installmod的模块列表</td>
</tr>
<tr>
<td>syswrite</td>
<td>将分区(例如system.img)重新挂载为可写分区，必要时重新启动。</td>
</tr>
</tbody></table>
<h4 id="validate-current-shell"><a href="#validate-current-shell" class="headerlink" title="validate_current_shell"></a>validate_current_shell</h4><p style="text-indent:2em"> 确定当前的shell环境，建立shell命令</p>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">validate_current_shell</span></span>() &#123;</span><br><span class="line">    <span class="built_in">local</span> current_sh=<span class="string">&quot;<span class="subst">$(ps -o command -p $$)</span>&quot;</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;<span class="variable">$current_sh</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">        *bash*)</span><br><span class="line">            <span class="keyword">function</span> <span class="function"><span class="title">check_type</span></span>() &#123; <span class="built_in">type</span> -t <span class="string">&quot;<span class="variable">$1</span>&quot;</span>; &#125;</span><br><span class="line">            ;;</span><br><span class="line">        *zsh*)</span><br><span class="line">            <span class="keyword">function</span> <span class="function"><span class="title">check_type</span></span>() &#123; <span class="built_in">type</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span>; &#125;</span><br><span class="line">            enable_zsh_completion ;;</span><br><span class="line">        *)</span><br><span class="line">            <span class="built_in">echo</span> -e <span class="string">&quot;WARNING: Only bash and zsh are supported.\nUse of other shell would lead to erroneous results.&quot;</span></span><br><span class="line">            ;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="source-vendorsetup"><a href="#source-vendorsetup" class="headerlink" title="source_vendorsetup"></a>source_vendorsetup</h4><p style="text-indent:2em"> 从device\vendor\product等目录遍历搜索vendorsetup.sh,并source进来</p>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Execute the contents of any vendorsetup.sh files we can find.</span></span><br><span class="line"><span class="comment"># Unless we find an allowed-vendorsetup_sh-files file, in which case we&#x27;ll only</span></span><br><span class="line"><span class="comment"># load those.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This allows loading only approved vendorsetup.sh files</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">source_vendorsetup</span></span>() &#123;</span><br><span class="line">    <span class="built_in">unset</span> VENDOR_PYTHONPATH</span><br><span class="line">    <span class="built_in">local</span> T=<span class="string">&quot;<span class="subst">$(gettop)</span>&quot;</span></span><br><span class="line">    allowed=</span><br><span class="line">    <span class="keyword">for</span> f <span class="keyword">in</span> $(<span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$T</span>&quot;</span> &amp;&amp; find -L device vendor product -maxdepth 4 -name <span class="string">&#x27;allowed-vendorsetup_sh-files&#x27;</span> 2&gt;/dev/null | sort); <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$allowed</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;More than one &#x27;allowed_vendorsetup_sh-files&#x27; file found, not including any vendorsetup.sh files:&quot;</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;  <span class="variable">$allowed</span>&quot;</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;  <span class="variable">$f</span>&quot;</span></span><br><span class="line">            <span class="built_in">return</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">        allowed=<span class="string">&quot;<span class="variable">$T</span>/<span class="variable">$f</span>&quot;</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">    allowed_files=</span><br><span class="line">    [ -n <span class="string">&quot;<span class="variable">$allowed</span>&quot;</span> ] &amp;&amp; allowed_files=$(cat <span class="string">&quot;<span class="variable">$allowed</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> dir <span class="keyword">in</span> device vendor product; <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">for</span> f <span class="keyword">in</span> $(<span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$T</span>&quot;</span> &amp;&amp; <span class="built_in">test</span> -d <span class="variable">$dir</span> &amp;&amp; \</span><br><span class="line">            find -L <span class="variable">$dir</span> -maxdepth 4 -name <span class="string">&#x27;vendorsetup.sh&#x27;</span> 2&gt;/dev/null | sort); <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> [[ -z <span class="string">&quot;<span class="variable">$allowed</span>&quot;</span> || <span class="string">&quot;<span class="variable">$allowed_files</span>&quot;</span> =~ <span class="variable">$f</span> ]]; <span class="keyword">then</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="string">&quot;including <span class="variable">$f</span>&quot;</span>; . <span class="string">&quot;<span class="variable">$T</span>/<span class="variable">$f</span>&quot;</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="string">&quot;ignoring <span class="variable">$f</span>, not in <span class="variable">$allowed</span>&quot;</span></span><br><span class="line">            <span class="keyword">fi</span></span><br><span class="line">        <span class="keyword">done</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 例：</span></span><br><span class="line"><span class="comment"># 	1.建立一个目录：/vendor/luojianwei/build</span></span><br><span class="line"><span class="comment"># 	2.创建一个vendorsetup.sh</span></span><br><span class="line"><span class="comment">#   	写一个log: echo &quot;vendor build test.&quot;</span></span><br><span class="line"><span class="comment"># 	3.执行source build/envsetup.sh</span></span><br><span class="line">. build/envsetup.sh</span><br><span class="line"><span class="comment"># source后打印：</span></span><br><span class="line"><span class="comment"># including vendor/luojianwei/build/vendorsetup.sh</span></span><br><span class="line"><span class="comment"># vendor build test.</span></span><br></pre></td></tr></table></figure>

<h4 id="addcompletions"><a href="#addcompletions" class="headerlink" title="addcompletions"></a>addcompletions</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">addcompletions</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">local</span> f=</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Keep us from trying to run in something that&#x27;s neither bash nor zsh.</span></span><br><span class="line">    <span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$BASH_VERSION</span>&quot;</span> -a -z <span class="string">&quot;<span class="variable">$ZSH_VERSION</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">return</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Keep us from trying to run in bash that&#x27;s too old.</span></span><br><span class="line">    <span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$BASH_VERSION</span>&quot;</span> -a <span class="variable">$&#123;BASH_VERSINFO[0]&#125;</span> -lt 3 ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">return</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">local</span> completion_files=(</span><br><span class="line">      system/core/adb/adb.bash</span><br><span class="line">      system/core/fastboot/fastboot.bash</span><br><span class="line">      tools/asuite/asuite.sh</span><br><span class="line">    )</span><br><span class="line">    <span class="comment"># Completion can be disabled selectively to allow users to use non-standard completion.</span></span><br><span class="line">    <span class="comment"># e.g.</span></span><br><span class="line">    <span class="comment"># ENVSETUP_NO_COMPLETION=adb # -&gt; disable adb completion</span></span><br><span class="line">    <span class="comment"># ENVSETUP_NO_COMPLETION=adb:bit # -&gt; disable adb and bit completion</span></span><br><span class="line">    <span class="keyword">for</span> f <span class="keyword">in</span> <span class="variable">$&#123;completion_files[*]&#125;</span>; <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> [ -f <span class="string">&quot;<span class="variable">$f</span>&quot;</span> ] &amp;&amp; should_add_completion <span class="string">&quot;<span class="variable">$f</span>&quot;</span>; <span class="keyword">then</span></span><br><span class="line">            . <span class="variable">$f</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> should_add_completion bit ; <span class="keyword">then</span></span><br><span class="line">        complete -C <span class="string">&quot;bit --tab&quot;</span> bit</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$ZSH_VERSION</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="comment"># Doesn&#x27;t work in zsh.</span></span><br><span class="line">        complete -o nospace -F _croot croot</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    complete -F _lunch lunch</span><br><span class="line"></span><br><span class="line">    complete -F _complete_android_module_names pathmod</span><br><span class="line">    complete -F _complete_android_module_names gomod</span><br><span class="line">    complete -F _complete_android_module_names outmod</span><br><span class="line">    complete -F _complete_android_module_names installmod</span><br><span class="line">    complete -F _complete_android_module_names m</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="lunch-aosp-arm-eng"><a href="#lunch-aosp-arm-eng" class="headerlink" title="lunch aosp_arm_eng"></a>lunch aosp_arm_eng</h3><h4 id="lunch说明"><a href="#lunch说明" class="headerlink" title="lunch说明"></a>lunch说明</h4><p style="text-indent:2em"> 环境变量初始化完成后，我们需要选择一个编译目标。lunch 主要作用是根据用户输入或者选择的产品名来设置与具体产品相关的环境变量。如果你不知道想要编译的目标是什么，直接执行一个lunch命令，会列出所有的目标，直接回车，会默认使用aosp_arm-eng这个目标。</p>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">You<span class="string">&#x27;re building on Linux</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Lunch menu... pick a combo:</span></span><br><span class="line"><span class="string">     1. aosp_arm-eng</span></span><br><span class="line"><span class="string">     2. aosp_arm64-eng</span></span><br><span class="line"><span class="string">     3. aosp_blueline-userdebug</span></span><br><span class="line"><span class="string">     4. aosp_blueline_car-userdebug</span></span><br><span class="line"><span class="string">     5. aosp_bonito-userdebug</span></span><br><span class="line"><span class="string">     6. aosp_bonito_car-userdebug</span></span><br><span class="line"><span class="string">     7. aosp_bramble-userdebug</span></span><br><span class="line"><span class="string">     8. aosp_car_arm-userdebug</span></span><br><span class="line"><span class="string">     9. aosp_car_arm64-userdebug</span></span><br><span class="line"><span class="string">     10. aosp_car_x86-userdebug</span></span><br><span class="line"><span class="string">     11. aosp_car_x86_64-userdebug</span></span><br><span class="line"><span class="string">     12. aosp_cf_arm64_auto-userdebug</span></span><br><span class="line"><span class="string">     13. aosp_cf_arm64_phone-userdebug</span></span><br><span class="line"><span class="string">     14. aosp_cf_x86_64_pc-userdebug</span></span><br><span class="line"><span class="string">     15. aosp_cf_x86_64_phone-userdebug</span></span><br><span class="line"><span class="string">     16. aosp_cf_x86_auto-userdebug</span></span><br><span class="line"><span class="string">     17. aosp_cf_x86_phone-userdebug</span></span><br><span class="line"><span class="string">     18. aosp_cf_x86_tv-userdebug</span></span><br><span class="line"><span class="string">     19. aosp_coral-userdebug</span></span><br><span class="line"><span class="string">     20. aosp_coral_car-userdebug</span></span><br><span class="line"><span class="string">     21. aosp_crosshatch-userdebug</span></span><br><span class="line"><span class="string">     22. aosp_crosshatch_car-userdebug</span></span><br><span class="line"><span class="string">     23. aosp_flame-userdebug</span></span><br><span class="line"><span class="string">     24. aosp_flame_car-userdebug</span></span><br><span class="line"><span class="string">     25. aosp_redfin-userdebug</span></span><br><span class="line"><span class="string">     26. aosp_sargo-userdebug</span></span><br><span class="line"><span class="string">     27. aosp_sunfish-userdebug</span></span><br><span class="line"><span class="string">     28. aosp_trout_arm64-userdebug</span></span><br><span class="line"><span class="string">     29. aosp_trout_x86-userdebug</span></span><br><span class="line"><span class="string">     30. aosp_x86-eng</span></span><br><span class="line"><span class="string">     31. aosp_x86_64-eng</span></span><br><span class="line"><span class="string">     32. arm_krait-eng</span></span><br><span class="line"><span class="string">     33. arm_v7_v8-eng</span></span><br><span class="line"><span class="string">     34. armv8-eng</span></span><br><span class="line"><span class="string">     35. armv8_cortex_a55-eng</span></span><br><span class="line"><span class="string">     36. armv8_kryo385-eng</span></span><br><span class="line"><span class="string">     37. beagle_x15-userdebug</span></span><br><span class="line"><span class="string">     38. beagle_x15_auto-userdebug</span></span><br><span class="line"><span class="string">     39. car_x86_64-userdebug</span></span><br><span class="line"><span class="string">     40. db845c-userdebug</span></span><br><span class="line"><span class="string">     41. fuchsia_arm64-eng</span></span><br><span class="line"><span class="string">     42. fuchsia_x86_64-eng</span></span><br><span class="line"><span class="string">     43. hikey-userdebug</span></span><br><span class="line"><span class="string">     44. hikey64_only-userdebug</span></span><br><span class="line"><span class="string">     45. hikey960-userdebug</span></span><br><span class="line"><span class="string">     46. hikey960_tv-userdebug</span></span><br><span class="line"><span class="string">     47. hikey_tv-userdebug</span></span><br><span class="line"><span class="string">     48. pixel3_mainline-userdebug</span></span><br><span class="line"><span class="string">     49. poplar-eng</span></span><br><span class="line"><span class="string">     50. poplar-user</span></span><br><span class="line"><span class="string">     51. poplar-userdebug</span></span><br><span class="line"><span class="string">     52. qemu_trusty_arm64-userdebug</span></span><br><span class="line"><span class="string">     53. silvermont-eng</span></span><br><span class="line"><span class="string">     54. uml-userdebug</span></span><br><span class="line"><span class="string">     55. yukawa-userdebug</span></span><br><span class="line"><span class="string">     56. yukawa_sei510-userdebug</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Which would you like? [aosp_arm-eng]</span></span><br></pre></td></tr></table></figure>

<p style="text-indent:2em"> 执行命令：lunch 1， 可以看到配置的一些环境变量。</p>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">============================================</span><br><span class="line">PLATFORM_VERSION_CODENAME=S</span><br><span class="line">PLATFORM_VERSION=S</span><br><span class="line">TARGET_PRODUCT=aosp_arm</span><br><span class="line">TARGET_BUILD_VARIANT=eng</span><br><span class="line">TARGET_BUILD_TYPE=release</span><br><span class="line">TARGET_ARCH=arm</span><br><span class="line">TARGET_ARCH_VARIANT=armv7-a-neon</span><br><span class="line">TARGET_CPU_VARIANT=generic</span><br><span class="line">HOST_ARCH=x86_64</span><br><span class="line">HOST_2ND_ARCH=x86</span><br><span class="line">HOST_OS=linux</span><br><span class="line">HOST_OS_EXTRA=Linux-4.4.0-186-generic-x86_64-Ubuntu-16.04.7-LTS</span><br><span class="line">HOST_CROSS_OS=windows</span><br><span class="line">HOST_CROSS_ARCH=x86</span><br><span class="line">HOST_CROSS_2ND_ARCH=x86_64</span><br><span class="line">HOST_BUILD_TYPE=release</span><br><span class="line">BUILD_ID=AOSP.MASTER</span><br><span class="line">OUT_DIR=out</span><br><span class="line">PRODUCT_SOONG_NAMESPACES=device/generic/goldfish device/generic/goldfish-opengl hardware/google/camera hardware/google/camera/devices/EmulatedCamera device/generic/goldfish device/generic/goldfish-opengl</span><br><span class="line">============================================</span><br></pre></td></tr></table></figure>

<p style="text-indent:2em"> 这些环境变量的含义如下：</p>

<table>
<thead>
<tr>
<th>lunch结果</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>PLATFORM_VERSION_CODENAME=S</td>
<td>表示平台版本的名称</td>
</tr>
<tr>
<td>PLATFORM_VERSION=S</td>
<td>Android平台的版本号</td>
</tr>
<tr>
<td>TARGET_PRODUCT=aosp_arm</td>
<td>所编译的产品名称</td>
</tr>
<tr>
<td>TARGET_BUILD_VARIANT=userdebug</td>
<td>所编译产品的类型</td>
</tr>
<tr>
<td>TARGET_BUILD_TYPE=release</td>
<td>编译的类型，debug和release</td>
</tr>
<tr>
<td>TARGET_ARCH=arm</td>
<td>表示编译目标的CPU架构</td>
</tr>
<tr>
<td>ARGET_ARCH_VARIANT=armv7-a-neon</td>
<td>表示编译目标的CPU架构版本</td>
</tr>
<tr>
<td>TARGET_CPU_VARIANT=generic</td>
<td>表示编译目标的CPU代号</td>
</tr>
<tr>
<td>HOST_ARCH=x86_64</td>
<td>表示编译平台的架构</td>
</tr>
<tr>
<td>HOST_2ND_ARCH=x86</td>
<td></td>
</tr>
<tr>
<td>HOST_OS=linux</td>
<td>表示编译平台的操作系统</td>
</tr>
<tr>
<td>HOST_OS_EXTRA=Linux-4.4.0-186-generic-x86_64-Ubuntu-16.04.7-LTS</td>
<td>编译系统之外的额外信息</td>
</tr>
<tr>
<td>HOST_CROSS_OS=windows</td>
<td></td>
</tr>
<tr>
<td>HOST_CROSS_ARCH=x86</td>
<td></td>
</tr>
<tr>
<td>HOST_CROSS_2ND_ARCH=x86_64</td>
<td></td>
</tr>
<tr>
<td>HOST_BUILD_TYPE=release</td>
<td></td>
</tr>
<tr>
<td>BUILD_ID=AOSP.MASTER</td>
<td>BUILD_ID会出现在版本信息中，可以利用</td>
</tr>
<tr>
<td>OUT_DIR</td>
<td></td>
</tr>
<tr>
<td>PRODUCT_SOONG_NAMESPACES</td>
<td></td>
</tr>
</tbody></table>
<p style="text-indent:2em"> lunch aosp_arm-eng 结束后，后创建一个out文件夹，生成一些中间文件。</p>

<h4 id="lunch"><a href="#lunch" class="headerlink" title="lunch()"></a>lunch()</h4><p style="text-indent:2em"> lunch命令用来设置 TARGET_PRODUCT、TARGET_BUILD_VARIANT、TARGET_PLATFORM_VERSION、TARGET_BUILD_TYPE、TARGET_BUILD_APPS等环境变量。lunch操作流程如下：</p>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.获取lunch操作的参数，如果参数不为空，参数则为指定要编译的设备型号和编译类型；如果参数为空，会调用print_lunch_menu来显示Lunch菜单项，读取用户的输入，存入answer</span><br><span class="line">2.如果answer为空，即之前在lunch菜单中用户只敲了一个回车。会将默认选项改为aosp_arm-eng，结果存入selection</span><br><span class="line">3.如果lunch操作得到的输入是数字，则将数字转换为LUNCH_MENU_CHOICES中的字符串，结果存入selection</span><br><span class="line">4.解析selection的值，得到 product = aosp_arm 和 variant = eng, 把他们分别保存到 TARGET_PRODUCT 和 TARGET_BUILD_VARIANT 中</span><br><span class="line">5.根据前面的设置，调用build_build_var_cache 来更新编译环境相关变量</span><br><span class="line">6.export 编译选项TARGET_PRODUCT, TARGET_BUILD_VARIANT和TARGET_BUILD_TYPE三元组</span><br><span class="line">7.调用set_stuff_for_environment 来设置其他环境变量，如PROMPT_COMMAND，编译toolchain和tools相关的路径等</span><br><span class="line">8.调用printconfig 来输出当前的设置选项</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">lunch</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">local</span> answer</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [[ <span class="variable">$#</span> -gt 1 ]]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;usage: lunch [target]&quot;</span> &gt;&amp;2</span><br><span class="line">        <span class="built_in">return</span> 1</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        answer=<span class="variable">$1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        print_lunch_menu</span><br><span class="line">        <span class="built_in">echo</span> -n <span class="string">&quot;Which would you like? [aosp_arm-eng] &quot;</span></span><br><span class="line">        <span class="built_in">read</span> answer</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">local</span> selection=</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$answer</span>&quot;</span> ]</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        selection=aosp_arm-eng</span><br><span class="line">    <span class="keyword">elif</span> (<span class="built_in">echo</span> -n <span class="variable">$answer</span> | grep -q -e <span class="string">&quot;^[0-9][0-9]*$&quot;</span>)</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">local</span> choices=($(TARGET_BUILD_APPS= get_build_var COMMON_LUNCH_CHOICES))</span><br><span class="line">        <span class="keyword">if</span> [ <span class="variable">$answer</span> -le <span class="variable">$&#123;#choices[@]&#125;</span> ]</span><br><span class="line">        <span class="keyword">then</span></span><br><span class="line">            <span class="comment"># array in zsh starts from 1 instead of 0.</span></span><br><span class="line">            <span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$ZSH_VERSION</span>&quot;</span> ]</span><br><span class="line">            <span class="keyword">then</span></span><br><span class="line">                selection=<span class="variable">$&#123;choices[$(($answer))]&#125;</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                selection=<span class="variable">$&#123;choices[$(($answer-1))]&#125;</span></span><br><span class="line">            <span class="keyword">fi</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        selection=<span class="variable">$answer</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">export</span> TARGET_BUILD_APPS=</span><br><span class="line"></span><br><span class="line">    <span class="built_in">local</span> product variant_and_version variant version</span><br><span class="line">    product=<span class="variable">$&#123;selection%%-*&#125;</span> <span class="comment"># Trim everything after first dash</span></span><br><span class="line">    variant_and_version=<span class="variable">$&#123;selection#*-&#125;</span> <span class="comment"># Trim everything up to first dash</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$variant_and_version</span>&quot;</span> != <span class="string">&quot;<span class="variable">$selection</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        variant=<span class="variable">$&#123;variant_and_version%%-*&#125;</span></span><br><span class="line">        <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$variant</span>&quot;</span> != <span class="string">&quot;<span class="variable">$variant_and_version</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">            version=<span class="variable">$&#123;variant_and_version#*-&#125;</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$product</span>&quot;</span> ]</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;Invalid lunch combo: <span class="variable">$selection</span>&quot;</span></span><br><span class="line">        <span class="built_in">return</span> 1</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    TARGET_PRODUCT=<span class="variable">$product</span> \</span><br><span class="line">    TARGET_BUILD_VARIANT=<span class="variable">$variant</span> \</span><br><span class="line">    TARGET_PLATFORM_VERSION=<span class="variable">$version</span> \</span><br><span class="line">    build_build_var_cache</span><br><span class="line">    <span class="keyword">if</span> [ $? -ne 0 ]</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$product</span>&quot;</span> =~ .*_(eng|user|userdebug) ]]</span><br><span class="line">        <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;Did you mean -<span class="variable">$&#123;product/*_/&#125;</span>? (dash instead of underscore)&quot;</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">        <span class="built_in">return</span> 1</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="built_in">export</span> TARGET_PRODUCT=$(get_build_var TARGET_PRODUCT)</span><br><span class="line">    <span class="built_in">export</span> TARGET_BUILD_VARIANT=$(get_build_var TARGET_BUILD_VARIANT)</span><br><span class="line">    <span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$version</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">      <span class="built_in">export</span> TARGET_PLATFORM_VERSION=$(get_build_var TARGET_PLATFORM_VERSION)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">unset</span> TARGET_PLATFORM_VERSION</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="built_in">export</span> TARGET_BUILD_TYPE=release</span><br><span class="line"></span><br><span class="line">    [[ -n <span class="string">&quot;<span class="variable">$&#123;ANDROID_QUIET_BUILD:-&#125;</span>&quot;</span> ]] || <span class="built_in">echo</span></span><br><span class="line"></span><br><span class="line">    set_stuff_for_environment</span><br><span class="line">    [[ -n <span class="string">&quot;<span class="variable">$&#123;ANDROID_QUIET_BUILD:-&#125;</span>&quot;</span> ]] || printconfig</span><br><span class="line">    destroy_build_var_cache</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="build-build-var-cache"><a href="#build-build-var-cache" class="headerlink" title="build_build_var_cache()"></a>build_build_var_cache()</h5><p style="text-indent:2em"> 根据前面的设置，更新编译环境相关变量。主要通过执行 "build/soong/soong_ui.bash --dumpvars-mode" 完成，最终执行的是 "./out/soog_ui  --dumpvars-mode"。</p>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Get all the build variables needed by this script in a single call to the build system.</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">build_build_var_cache</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">local</span> T=$(gettop)</span><br><span class="line">    <span class="comment"># Grep out the variable names from the script.</span></span><br><span class="line">    cached_vars=(`cat <span class="variable">$T</span>/build/envsetup.sh | tr <span class="string">&#x27;()&#x27;</span> <span class="string">&#x27;  &#x27;</span> | awk <span class="string">&#x27;&#123;for(i=1;i&lt;=NF;i++) if($i~/get_build_var/) print $(i+1)&#125;&#x27;</span> | sort -u | tr <span class="string">&#x27;\n&#x27;</span> <span class="string">&#x27; &#x27;</span>`)</span><br><span class="line">    cached_abs_vars=(`cat <span class="variable">$T</span>/build/envsetup.sh | tr <span class="string">&#x27;()&#x27;</span> <span class="string">&#x27;  &#x27;</span> | awk <span class="string">&#x27;&#123;for(i=1;i&lt;=NF;i++) if($i~/get_abs_build_var/) print $(i+1)&#125;&#x27;</span> | sort -u | tr <span class="string">&#x27;\n&#x27;</span> <span class="string">&#x27; &#x27;</span>`)</span><br><span class="line">    <span class="comment"># Call the build system to dump the &quot;&lt;val&gt;=&lt;value&gt;&quot; pairs as a shell script.</span></span><br><span class="line">    build_dicts_script=`\<span class="built_in">builtin</span> <span class="built_in">cd</span> <span class="variable">$T</span>; build/soong/soong_ui.bash --dumpvars-mode \</span><br><span class="line">                        --vars=<span class="string">&quot;<span class="variable">$&#123;cached_vars[*]&#125;</span>&quot;</span> \</span><br><span class="line">                        --abs-vars=<span class="string">&quot;<span class="variable">$&#123;cached_abs_vars[*]&#125;</span>&quot;</span> \</span><br><span class="line">                        --var-prefix=var_cache_ \</span><br><span class="line">                        --abs-var-prefix=abs_var_cache_`</span><br><span class="line">    <span class="built_in">local</span> ret=$?</span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$ret</span> -ne 0 ]</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">unset</span> build_dicts_script</span><br><span class="line">        <span class="built_in">return</span> <span class="variable">$ret</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="comment"># Execute the script to store the &quot;&lt;val&gt;=&lt;value&gt;&quot; pairs as shell variables.</span></span><br><span class="line">    <span class="built_in">eval</span> <span class="string">&quot;<span class="variable">$build_dicts_script</span>&quot;</span></span><br><span class="line">    ret=$?</span><br><span class="line">    <span class="built_in">unset</span> build_dicts_script</span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$ret</span> -ne 0 ]</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">return</span> <span class="variable">$ret</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    BUILD_VAR_CACHE_READY=<span class="string">&quot;true&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p style="text-indent:2em"> soong_ui 由build/soong/cmd/soong_ui/main.go编译生成:</p>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[build/soong/cmd/soong_ui/main.<span class="keyword">go</span>]</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> os.Args[<span class="number">1</span>] == <span class="string">&quot;--dumpvar-mode&quot;</span> &#123;</span><br><span class="line">        dumpVar(buildCtx, config, os.Args[<span class="number">2</span>:])</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> os.Args[<span class="number">1</span>] == <span class="string">&quot;--dumpvars-mode&quot;</span> &#123;</span><br><span class="line">        dumpVars(buildCtx, config, os.Args[<span class="number">2</span>:])</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">[build/soong/cmd/soong_ui/main.<span class="keyword">go</span>]</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dumpVars</span><span class="params">(ctx build.Context, config build.Config, args []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">       varData, err := build.DumpMakeVars(ctx, config, <span class="literal">nil</span>, allVars)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p style="text-indent:2em"> 最后调用到了ckati执行-f build/make/core/config.mk</p>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">[/build/soong/ui/build/dumpvars.<span class="keyword">go</span>]</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dumpMakeVars</span><span class="params">(ctx Context, config Config, goals, vars []<span class="keyword">string</span>, write_soong_vars <span class="keyword">bool</span>)</span> <span class="params">(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">    ctx.BeginTrace(metrics.RunKati, <span class="string">&quot;dumpvars&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> ctx.EndTrace()</span><br><span class="line"> </span><br><span class="line">    cmd := Command(ctx, config, <span class="string">&quot;dumpvars&quot;</span>,</span><br><span class="line">        config.PrebuiltBuildTool(<span class="string">&quot;ckati&quot;</span>),</span><br><span class="line">        <span class="string">&quot;-f&quot;</span>, <span class="string">&quot;build/make/core/config.mk&quot;</span>,</span><br><span class="line">        <span class="string">&quot;--color_warnings&quot;</span>,</span><br><span class="line">        <span class="string">&quot;--kati_stats&quot;</span>,</span><br><span class="line">        <span class="string">&quot;dump-many-vars&quot;</span>,</span><br><span class="line">        <span class="string">&quot;MAKECMDGOALS=&quot;</span>+strings.Join(goals, <span class="string">&quot; &quot;</span>))</span><br><span class="line">    cmd.Environment.Set(<span class="string">&quot;CALLED_FROM_SETUP&quot;</span>, <span class="string">&quot;true&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> write_soong_vars &#123;</span><br><span class="line">        cmd.Environment.Set(<span class="string">&quot;WRITE_SOONG_VARIABLES&quot;</span>, <span class="string">&quot;true&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    cmd.Environment.Set(<span class="string">&quot;DUMP_MANY_VARS&quot;</span>, strings.Join(vars, <span class="string">&quot; &quot;</span>))</span><br><span class="line">    cmd.Sandbox = dumpvarsSandbox</span><br><span class="line">    output := bytes.Buffer&#123;&#125;</span><br><span class="line">    cmd.Stdout = &amp;output</span><br><span class="line">    pipe, err := cmd.StderrPipe()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        ctx.Fatalln(<span class="string">&quot;Error getting output pipe for ckati:&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    cmd.StartOrFatal()</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> error out when Stderr contains any content</span></span><br><span class="line">    status.KatiReader(ctx.Status.StartTool(), pipe)</span><br><span class="line">    cmd.WaitOrFatal()</span><br><span class="line"> </span><br><span class="line">    ret := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, <span class="built_in">len</span>(vars))</span><br><span class="line">    ...</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> ret, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p style="text-indent:2em"> 下面我们单独研究一下config.mk。</p>

<h3 id="config-mk"><a href="#config-mk" class="headerlink" title="config.mk"></a>config.mk</h3><p><img src="/.top//config.jpg" alt="img"></p>
<p style="text-indent:2em"> 说明：config.mk首先加载了build/make/common 中的core.mk、math.mk、strings.mk、json.mk 用来配置一些shell环境、math函数、string和json的一些支持函数。最主要的操作还是加载build/make/core中的envsetup.mk和dumpvar.mk</p>

<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">#配置两个目录的变量，供之后的mk使用</span></span><br><span class="line">BUILD_SYSTEM :=$= build/make/core</span><br><span class="line">BUILD_SYSTEM_COMMON :=$= build/make/common</span><br><span class="line"> </span><br><span class="line"><span class="comment">#加载core.mk， 只使用ANDROID_BUILD_SHELL来包装bash。</span></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(BUILD_SYSTEM_COMMON)</span>/core.mk</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">#设置make中使用的有效数学函数。</span></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(BUILD_SYSTEM_COMMON)</span>/math.mk</span><br><span class="line"> </span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(BUILD_SYSTEM_COMMON)</span>/strings.mk</span><br><span class="line"> </span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(BUILD_SYSTEM_COMMON)</span>/json.mk</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 避免硬件解码路径被覆盖的调用pathmap.mk建立硬解映射</span></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(BUILD_SYSTEM)</span>/pathmap.mk</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 允许项目定义自己的全局可用变量</span></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(BUILD_SYSTEM)</span>/project_definitions.mk</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># ###############################################################</span></span><br><span class="line"><span class="comment"># Build system internal files</span></span><br><span class="line"><span class="comment"># ###############################################################</span></span><br><span class="line"><span class="comment"># 构建系统内部文件(写Android.mk时会调用include头文件，也就是这些makefile文件)</span></span><br><span class="line"> </span><br><span class="line">BUILD_COMBOS:= <span class="variable">$(BUILD_SYSTEM)</span>/combo</span><br><span class="line"> </span><br><span class="line">CLEAR_VARS:= <span class="variable">$(BUILD_SYSTEM)</span>/clear_vars.mk</span><br><span class="line"></span><br><span class="line">BUILD_HOST_STATIC_LIBRARY:= <span class="variable">$(BUILD_SYSTEM)</span>/host_static_library.mk</span><br><span class="line">BUILD_HOST_SHARED_LIBRARY:= <span class="variable">$(BUILD_SYSTEM)</span>/host_shared_library.mk</span><br><span class="line">BUILD_STATIC_LIBRARY:= <span class="variable">$(BUILD_SYSTEM)</span>/static_library.mk</span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line">BUILD_NOTICE_FILE := <span class="variable">$(BUILD_SYSTEM)</span>/notice_files.mk</span><br><span class="line">BUILD_HOST_DALVIK_JAVA_LIBRARY := <span class="variable">$(BUILD_SYSTEM)</span>/host_dalvik_java_library.mk</span><br><span class="line">BUILD_HOST_DALVIK_STATIC_JAVA_LIBRARY := <span class="variable">$(BUILD_SYSTEM)</span>/host_dalvik_static_java_library.mk</span><br><span class="line"> </span><br><span class="line">BUILD_HOST_TEST_CONFIG := <span class="variable">$(BUILD_SYSTEM)</span>/host_test_config.mk</span><br><span class="line">BUILD_TARGET_TEST_CONFIG := <span class="variable">$(BUILD_SYSTEM)</span>/target_test_config.mk</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">#定义大多数全局变量。这些是特定于用户的构建配置的。</span></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(BUILD_SYSTEM)</span>/envsetup.mk</span><br><span class="line"> </span><br><span class="line"><span class="comment">#构建系统为在哪里找到内核公开了几个变量</span></span><br><span class="line"><span class="comment">#(1)TARGET_DEVICE_KERNEL_HEADERS是为当前正在构建的设备自动创建的。</span></span><br><span class="line"><span class="comment">#它被设置为$(TARGET_DEVICE_DIR)/kernel-headers，</span></span><br><span class="line"><span class="comment">#例如DEVICE/samsung/tuna/kernel-headers。此目录不是由任何人显式设置的，生成系统总是添加此子目录。</span></span><br><span class="line">TARGET_DEVICE_KERNEL_HEADERS := <span class="variable">$(<span class="built_in">strip</span> $(<span class="built_in">wildcard</span> <span class="variable">$(TARGET_DEVICE_DIR)</span>/kernel-headers)</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#(2)TARGET_BOARD_KERNEL_HEADERS由BoardConfig.mk允许包含其他目录的文件。</span></span><br><span class="line"><span class="comment">#如果有一些常见的地方为一组设备保留了一些报头，那么这很有用。</span></span><br><span class="line"><span class="comment">#例如，device/&lt;vendor&gt;/common/kernel头可以包含一些&lt;vendor&gt;设备的头。</span></span><br><span class="line">TARGET_BOARD_KERNEL_HEADERS := <span class="variable">$(<span class="built_in">strip</span> $(<span class="built_in">wildcard</span> <span class="variable">$(TARGET_BOARD_KERNEL_HEADERS)</span>)</span>)</span><br><span class="line">TARGET_BOARD_KERNEL_HEADERS := <span class="variable">$(<span class="built_in">patsubst</span> %/,%,<span class="variable">$(TARGET_BOARD_KERNEL_HEADERS)</span>)</span></span><br><span class="line"><span class="variable">$(<span class="built_in">call</span> validate-kernel-headers,<span class="variable">$(TARGET_BOARD_KERNEL_HEADERS)</span>)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#(3)TARGET_PRODUCT_KERNEL_头由产品继承图生成。</span></span><br><span class="line"><span class="comment">#这允许体系结构产品为使用该体系结构的设备提供报头。</span></span><br><span class="line">TARGET_PRODUCT_KERNEL_HEADERS := <span class="variable">$(<span class="built_in">strip</span> $(<span class="built_in">wildcard</span> <span class="variable">$(PRODUCT_VENDOR_KERNEL_HEADERS)</span>)</span>)</span><br><span class="line">TARGET_PRODUCT_KERNEL_HEADERS := <span class="variable">$(<span class="built_in">patsubst</span> %/,%,<span class="variable">$(TARGET_PRODUCT_KERNEL_HEADERS)</span>)</span></span><br><span class="line"><span class="variable">$(<span class="built_in">call</span> validate-kernel-headers,<span class="variable">$(TARGET_PRODUCT_KERNEL_HEADERS)</span>)</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 选择一个Java编译器</span></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(BUILD_SYSTEM)</span>/combo/javac.mk</span><br><span class="line"> </span><br><span class="line"><span class="comment"># A list of SEPolicy versions, besides PLATFORM_SEPOLICY_VERSION, that the framework supports.</span></span><br><span class="line"><span class="comment">#框架支持的SEPolicy版本列表，除了PLATFORM_SEPOLICY_VERSION</span></span><br><span class="line">PLATFORM_SEPOLICY_COMPAT_VERSIONS := \</span><br><span class="line">    26.0 \</span><br><span class="line">    27.0 \</span><br><span class="line">    28.0 \</span><br><span class="line">    29.0 \</span><br><span class="line">    30.0 \</span><br><span class="line"> </span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(CALLED_FROM_SETUP)</span>,true)</span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(BUILD_SYSTEM)</span>/ninja_config.mk</span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(BUILD_SYSTEM)</span>/soong_config.mk</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#加载dumpvar.mk,用来生成make目标</span></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(BUILD_SYSTEM)</span>/dumpvar.mk</span><br></pre></td></tr></table></figure>

<h4 id="build-make-core-envsetup-mk"><a href="#build-make-core-envsetup-mk" class="headerlink" title="build/make/core/envsetup.mk"></a>build/make/core/envsetup.mk</h4><p style="text-indent:2em"> envsetup.mk 主要加载了product_config.mk和board_config.mk，用来得到TARGET_DEVICE和其他变量。</p>

<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">#设置host和target编译链相关的变量</span></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(BUILD_SYSTEM)</span>/combo/select.mk</span><br><span class="line"><span class="comment">#(1)阅读产品规格，这样我们就可以得到TARGET_DEVICE和其他变量，我们需要找到输出文件</span></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(BUILD_SYSTEM)</span>/product_config.mk</span><br><span class="line"> </span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(BUILD_SYSTEM)</span>/board_config.mk</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h4 id="build-make-core-board-config-mk"><a href="#build-make-core-board-config-mk" class="headerlink" title="build/make/core/board_config.mk"></a>build/make/core/board_config.mk</h4><p style="text-indent:2em"> 板级可以在$(SRC_TARGET_DIR)/board/$(TARGET_DEVICE)下定义，也可以在vendor/*/$(TARGET_DEVICE)下定义。在这两个地方搜索，但要确保只存在一个。真正的板级应始终与OEM vendor相关联。</p>

<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment"># Boards may be defined under $(SRC_TARGET_DIR)/board/$(TARGET_DEVICE)</span></span><br><span class="line"><span class="comment"># or under vendor/*/$(TARGET_DEVICE).  Search in both places, but</span></span><br><span class="line"><span class="comment"># make sure only one exists.</span></span><br><span class="line"><span class="comment"># Real boards should always be associated with an OEM vendor.</span></span><br><span class="line"><span class="keyword">ifdef</span> TARGET_DEVICE_DIR</span><br><span class="line">  <span class="keyword">ifneq</span> (<span class="variable">$(<span class="built_in">origin</span> TARGET_DEVICE_DIR)</span>,command line)</span><br><span class="line">    <span class="variable">$(<span class="built_in">error</span> TARGET_DEVICE_DIR may not be set manually)</span></span><br><span class="line">  <span class="keyword">endif</span></span><br><span class="line">  board_config_mk := <span class="variable">$(TARGET_DEVICE_DIR)</span>/BoardConfig.mk</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  board_config_mk := \</span><br><span class="line">    <span class="variable">$(<span class="built_in">strip</span> $(<span class="built_in">sort</span> $(<span class="built_in">wildcard</span> \</span></span><br><span class="line"><span class="variable">      <span class="variable">$(SRC_TARGET_DIR)</span>/board/<span class="variable">$(TARGET_DEVICE)</span>/BoardConfig.mk \</span></span><br><span class="line"><span class="variable">      $(<span class="built_in">shell</span> test -d device &amp;&amp; find -L device -maxdepth 4 -path &#x27;*/<span class="variable">$(TARGET_DEVICE)</span>/BoardConfig.mk&#x27;)</span> \</span><br><span class="line">      <span class="variable">$(<span class="built_in">shell</span> test -d vendor &amp;&amp; find -L vendor -maxdepth 4 -path &#x27;*/<span class="variable">$(TARGET_DEVICE)</span>/BoardConfig.mk&#x27;)</span> \</span><br><span class="line">    )))</span><br><span class="line">  <span class="keyword">ifeq</span> (<span class="variable">$(board_config_mk)</span>,)</span><br><span class="line">    <span class="variable">$(<span class="built_in">error</span> No config <span class="built_in">file</span> found for TARGET_DEVICE <span class="variable">$(TARGET_DEVICE)</span>)</span></span><br><span class="line">  <span class="keyword">endif</span></span><br><span class="line">  <span class="keyword">ifneq</span> (<span class="variable">$(words <span class="variable">$(board_config_mk)</span>)</span>,1)</span><br><span class="line">    <span class="variable">$(<span class="built_in">error</span> Multiple board config files for TARGET_DEVICE <span class="variable">$(TARGET_DEVICE)</span>: <span class="variable">$(board_config_mk)</span>)</span></span><br><span class="line">  <span class="keyword">endif</span></span><br><span class="line">  TARGET_DEVICE_DIR := <span class="variable">$(<span class="built_in">patsubst</span> %/,%,$(<span class="built_in">dir</span> <span class="variable">$(board_config_mk)</span>)</span>)</span><br><span class="line">  .KATI_READONLY := TARGET_DEVICE_DIR</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(board_config_mk)</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p style="text-indent:2em">至此，envsetup.sh 和lunch()的初始化流程基本上理清了，主要就是加载了环境变量，并选择了编译目标，后面只要执行一下make就能够进行启动编译，下一节让我们一起看看敲下make后到底发生了什么。</p>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://luojianwei.top/2021/06/15/Android-Q-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E9%9B%B6-%E5%BA%8F%E8%A8%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="罗建伟的个人博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="罗建伟的个人主页">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/15/Android-Q-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E9%9B%B6-%E5%BA%8F%E8%A8%80/" class="post-title-link" itemprop="url">Android Q 编译原理之零 序言</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-06-15 17:20:06" itemprop="dateCreated datePublished" datetime="2021-06-15T17:20:06+08:00">2021-06-15</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-07-13 18:16:18" itemprop="dateModified" datetime="2021-07-13T18:16:18+08:00">2021-07-13</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Compiler/" itemprop="url" rel="index"><span itemprop="name">Compiler</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p style="text-indent:2em">Android 的版本一直快速的进行迭代着，从我们以前最常见的 Android 4.4 一直发展到了今天的 Android 13.0 版本(即 Android K 到 Android T)，Android 版本的快速迭代对于消费者来说是一件好事，但是对于开发者来说各种适配各种改造有时候就很痛苦了。而对于 Android 版本的适配和各种改造的第一步就是从编译 Android 源码开始，可是不幸的是随着 Android 版本的迭代连编译 Android 源码的相关流程都发生了翻天覆地的变化。本系列基于 Android 10.0 进行编译系统的体系的一个梳理。</p>

<p>Android 各个版本的对应关系如下:</p>
<table>
<thead>
<tr>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
<th>12</th>
<th>13</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>K</td>
<td>L</td>
<td>M</td>
<td>N</td>
<td>O</td>
<td>P</td>
<td>Q</td>
<td>R</td>
<td>S</td>
<td>T</td>
<td></td>
</tr>
</tbody></table>
<h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><ul>
<li><a target="_blank" rel="noopener" href="https://ljw-luojianwei.github.io/2021/06/15/Android-Q-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E9%9B%B6-%E5%BA%8F%E8%A8%80">00.序言</a></li>
<li><a target="_blank" rel="noopener" href="https://ljw-luojianwei.github.io/2021/06/15/Android-Q-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E4%B8%80-%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8%E7%AF%87">01.编译系统入门篇</a></li>
<li><a target="_blank" rel="noopener" href="https://ljw-luojianwei.github.io/2021/06/16/Android-Q-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8C-%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%E5%88%9D%E5%A7%8B%E5%8C%96">02.编译环境初始化</a></li>
<li><a target="_blank" rel="noopener" href="https://ljw-luojianwei.github.io/2021/07/08/Android-Q-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E4%B8%89-make%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/">03.make编译过程</a></li>
<li><a target="_blank" rel="noopener" href="https://ljw-luojianwei.github.io/2021/07/08/Android-Q-%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%9B%9B-Image%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B/">04.Image打包流程</a></li>
<li><a target="_blank" rel="noopener" href="https://ljw-luojianwei.github.io/2021/07/08/Android-Q-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%94-Kati%E8%AF%A6%E8%A7%A3">05.Kati详解</a></li>
<li><a target="_blank" rel="noopener" href="https://ljw-luojianwei.github.io/2021/07/08/Android-Q-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E5%85%AD-Blueprint%E7%AE%80%E4%BB%8B/">06.Blueprint简介</a></li>
<li><a target="_blank" rel="noopener" href="https://ljw-luojianwei.github.io/2021/07/08/Android-Q-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E4%B8%83-Blueprint%E4%BB%A3%E7%A0%81%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/">07.Blueprint代码详细分析</a></li>
<li><a target="_blank" rel="noopener" href="https://ljw-luojianwei.github.io/2021/07/08/Android-Q-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E5%85%AB-Android-bp-%E8%AF%AD%E6%B3%95%E6%B5%85%E6%9E%90/">08.Android.bp 语法浅析</a></li>
<li><a target="_blank" rel="noopener" href="https://ljw-luojianwei.github.io/2021/07/08/Android-Q-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E4%B9%9D-Ninja%E7%AE%80%E4%BB%8B/">09.Ninja简介</a></li>
<li><a target="_blank" rel="noopener" href="https://ljw-luojianwei.github.io/2021/07/08/Android-Q-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E5%8D%81-Ninja%E6%8F%90%E5%8D%87%E7%BC%96%E8%AF%91%E9%80%9F%E5%BA%A6%E7%9A%84%E6%96%B9%E6%B3%95/">10.Ninja提升编译速度的方法</a></li>
<li><a target="_blank" rel="noopener" href="https://ljw-luojianwei.github.io/2021/07/08/Android-Q-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%8D%81%E4%B8%80-Soong-%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9F/">11.Soong 编译系统</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://luojianwei.top/2021/06/15/Android-Q-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E4%B8%80-%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8%E7%AF%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="罗建伟的个人博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="罗建伟的个人主页">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/15/Android-Q-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E4%B8%80-%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8%E7%AF%87/" class="post-title-link" itemprop="url">Android Q 编译原理之一 编译系统入门篇</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-06-15 17:18:08" itemprop="dateCreated datePublished" datetime="2021-06-15T17:18:08+08:00">2021-06-15</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-07-13 18:16:18" itemprop="dateModified" datetime="2021-07-13T18:16:18+08:00">2021-07-13</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Compiler/" itemprop="url" rel="index"><span itemprop="name">Compiler</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p style="text-indent:2em">在 Android 7.0 发布之前，Android 仅使用 GNU Make 描述和执行其构建规则，模块定义都使用 Android.mk 进行定义，Android.mk 的本质就是 Makefile，Make 构建系统得到了广泛的支持和使用，但随着Android 的工程越来越大，包含的模块越来越多，以 Makefile 组织的项目编译时间越来越长，在 Android 层面变得缓慢、容易出错、无法扩展且难以测试，Soong 构建系统正好提供了 Android build 所需的灵活性。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，从 Android 7.0 开始，Google 就先引入了<a target="_blank" rel="noopener" href="https://ninja-build.org" style="text-decoration:none"> ninja 编译系统 </a>来取代之前使用的 make，相对于 Makefile 来说 Ninja 在大的项目管理中速度和并行方面有突出的优势。由于之前的Android.mk 数据实在巨大，不可能把所有的 Android.mk 改写成 ninja 的构建规则，因此 Google 加入了一个 kati 工具，用于将 Android.mk 转换成 ninja 的构建规则文件 buildxxx.ninja，再使用 ninja 来进行构建工作。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;编译速度快了一些，但是既然要干，那就干个大的，最终目标要把 make 都取代，于是从 Android 8.0 开始，Google 为了进一步淘汰 Makefile，因此引入了 Android.bp 文件来替换之前的 Android.mk，Android.bp 只是一个纯粹的配置文件，不包括分支、循环语句等控制流程，本质上就是一个 json 配置文件。同时还引入 Soong 这个构建系统，Android.bp 通过 Blueprint+Soong 转换成 ninja 的构建规则文件 build.ninja，再使用 ninja 来进行构建工作。也可以通过 androidmk 将 Android.mk 转换成 Android.bp，但针对没有分支、循环等流程控制的 Android.mk 才有效。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但之前的模块全部是用 Android.mk 来定义的，Google 不可能一下子把所有模块都修改成 Android.bp，只能逐步替换。Android 10.0 上，mk 和 bp 编译的列表可以从 \out\.module_paths 中的 Android.bp.list、Android.mk.list 中看到，Android10.0 还有400多个 mk 文件没有被替换完，Google 任重道远。</p>

<p><img src="/.top//android_build.jpg" alt="android_build"></p>
<h3 id="Android编译演进过程："><a href="#Android编译演进过程：" class="headerlink" title="Android编译演进过程："></a>Android编译演进过程：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Android 7.0 之前使用 GNU Make</span><br><span class="line">Android 7.0 引入 ninja 编译框架、kati 转换工具。</span><br><span class="line">Android 8.0 引入 Android.bp 和 soong 构建系统，默认打开 Android.bp</span><br><span class="line">Android 9.0 强制使用 Android.bp</span><br></pre></td></tr></table></figure>

<h3 id="构建系统中Makefile、Android-mk、Ninja、Kati、Soong、Blueprint、Android-bp概念介绍"><a href="#构建系统中Makefile、Android-mk、Ninja、Kati、Soong、Blueprint、Android-bp概念介绍" class="headerlink" title="构建系统中Makefile、Android.mk、Ninja、Kati、Soong、Blueprint、Android.bp概念介绍"></a>构建系统中Makefile、Android.mk、Ninja、Kati、Soong、Blueprint、Android.bp概念介绍</h3><p style="text-indent:2em"><b>Makefile </b>Android 平台的编译系统其实就是用 Makefile 写出来的一个独立项目。它定义了编译的规则，实现了“自动化编译”，不仅把分散在数百个 Git 库中的代码整合起来、统一编译， 而且还把产物分门别类地输出到一个目录，打包成手机 ROM，还可以生成应用开发时所使用的 SDK、NDK 等。因此，采用 Makefile 编写的编译系统，也可以称为 Makefile 编译系统。Makefile 默认文件名为 Makefile 或 makefile，也常用 .make 或 .mk 作为文件后缀。</p>

<p style="text-indent:2em"><b>Android.mk</b> Makefile 编译系统的一部分，定义了一个模块的必要参数，使模块随着平台编译。通俗来讲就是告诉编译系统，以什么样的规则编译你的源代码，并生成对应的目标文件。</p>

<p style="text-indent:2em"><b>Ninja </b>ninja 是一个编译框架，会根据相应的 ninja 格式的配置文件进行编译，但是 ninja 文件一般不会手动修改，而是通过将 Android.bp 文件转换成 ninja 格文件来编译。Ninja 的默认文件名是 build.ninja，其它文件以 .ninja 为后缀。Makefile 与 Ninja 的核心区别在于设计哲学, Makefile 是设计来给开发编写的，而 Ninja 设计出来是给其它程序生成的。如果说 Makefile 是 C 语言，那么 Ninja 就是汇编语言，如果说 Makefile 是一个 DSL，那么 Ninja 就是一种配置文件。二者的相同点都是为了控制编译流程而设计，所以，他们的核心功能都是指定目标，以及目标之间的依赖关系，自动计算执行顺序。执行 Makefile 的程序，默认是 GNU make，也有一些其它的实现，Ninja 的执行程序，就是 ninja 命令。在 Android 项目中，make 需要编译主机上安装，作为环境的一部分，而 ninja命令则是 Android 平台代码自带，位于 prebuilts/build-tools/linux-x86/bin。</p>

<p style="text-indent:2em"><b>Kati </b>kati 是 Google 专为 Android 开发的一个基于 Golang 和 C++ 的工具，主要功能是把 Android 中的 Android.mk 文件转换成 Ninja 文件。Makefile 文件会通过 kati 转换为 Ninja 文件。在 Android 10.0 中代码路径是 build/kati ，编译后的产物是 ckati，位于 prebuilts/build-tools/linux-x86/bin。在 Android 11.0 之后就只保留工具 ckati 了，Kati 代码是开源的，可以把它 clone 下来，简单分析下它的运行原理。在 Android 全编译以后，可以使用 ninja 来编译已经生成的 .ninja文件。执行编译 odex 编译命令。</p>

<p style="text-indent:2em"><b>Blueprint和Soong </b>Blueprint是生成、解析Android.bp的工具，用于解析Android.bp文件翻译成Ninja语法文件，是Soong的一部分。Soong是谷歌用来替代此前的Makefile编译系统的替代品，类似于之前的Makefile编译系统的核心，Soong负责提供Android.bp文件的语义解析，并将之转换为Ninja文件。Soong还会编译生成一个androidmk命令，用于将Android.mk文件转换为Android.bp文件，不过这个转换功能仅限于没有分支、循环等流程控制的Android.mk才有效。Soong是负责Android编译而设计的工具，而Blueprint只是解析文件格式，Soong解析内容的具体含义。Blueprint负责解析Android.bp文件内容，Blueprint类似一个处理相关语法的库文件，Soong则是定义具体如何处理相应的语法以及命令实现。通俗来讲就是Soong借助于Blueprint定义的Android.bp语法，完成Android.bp的解析，最终转换成Ninja文件。Blueprint和Soong都是由Golang写的项目，从Android 7.0，prebuilts/go/目录下新增Golang所需的运行环境，在编译时使用。因为Soong和Blueprint是Google为Android.bp特别定制的工具，所以不要摘出来单独来操作。</p>

<p style="text-indent:2em"><b>Android.bp </b>Android.bp的出现就是为了替换Android.mk文件。bp跟mk文件不同，它是纯粹的配置，没有分支、循环等流程控制，不能做算术逻辑运算。如果需要控制逻辑，那么只能通过Go语言编写。
编译android源码后，androidmk工具会生成在：out/soong/host/linux-x86/bin目录下，用于Android.mk转换成Android.bp使用。</p>

<p style="text-indent:2em"><b>Android.mk、Ninja、Soong、Blueprint、kati、Android.bp的概念之间的联系为：</b></p>

<p><img src="/.top//VZRxYQ.png" alt="VZRxYQ.png"></p>
<p style="text-indent:2em">在编译过程中，Android.bp会被收集到out/soong/build.ninja.d，blueprint以此为基础，生成out/soong/build.ninja，Android.mk会由kati/ckati生成为out/build-aosp_arm.ninja，两个ninja文件会被整合进入out/combined-aosp_arm.ninja。</p>

<p><img src="/.top//ninja.png" alt="ninja"></p>
<p><strong>out/combined-aosp_arm.ninja内容如下所示：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">builddir = out</span><br><span class="line">include out/build-aosp_arm.ninja</span><br><span class="line">include out/soong/build.ninja</span><br><span class="line">build out/combined-aosp_arm.ninja: phony out/soong/build.ninja</span><br></pre></td></tr></table></figure>

<p style="text-indent:2em">Android的编译目录在/build 中，看一下Android 10.0源码中的build目录，现在是这个样子：</p>

<p><img src="/.top//20201014202635594.jpg" alt="img"></p>
<p style="text-indent:2em">这个目录中可以看到core文件夹被link到了make/core，envsetup.sh被link到make/envsetup.sh，这主要是为了对使用者屏蔽切换编译系统的差异。这里重点看四个文件夹：blueprint、kati、make、soong：</p>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">blueprint：用于处理Android.bp，编译生成*.ninja文件，用于做ninja的处理</span><br><span class="line">kati：用于处理Android.mk，编译生成.ninja文件，用于做ninja的处理</span><br><span class="line">soong：构建系统，核心编译为soong_ui.bash</span><br><span class="line">make：文件夹还是原始的make那一套流程，比如envsetup.sh</span><br></pre></td></tr></table></figure>

<h3 id="编译源码的方式"><a href="#编译源码的方式" class="headerlink" title="编译源码的方式"></a>编译源码的方式</h3><p style="text-indent:2em">Androd系统源码编译有很多种方式，主要有以下几种：</p>

<ul>
<li>在Linux中直接进行系统源码编译(Android官方支持)</li>
<li>在Mac OS中直接进行系统源码编译(Android官方支持)</li>
<li>使用<a target="_blank" rel="noopener" href="https://www.docker.com/products">Docker</a>编译，支持Mac OS和Windows。</li>
</ul>
<p style="text-indent:2em">其中需要注意的是，Docker的最低支持版本为Windows7，建议用Windows10环境下使用Docker，因为在Windows7种还需要借助Docker Toolbox和VirtualBox中的容器进行通信，效率相对低些。</p>

<h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><ol>
<li>下载依赖包</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install git-core gnupg flex bison gperf build-essential zip curl zlib1g-dev gcc-multilib g++-multilib libc6-dev-i386 lib32ncurses5-dev x11proto-core-dev libx11-dev lib32z-dev ccache libgl1-mesa-dev libxml2-utils xsltproc unzip m4 libssl-dev libswitch-perl</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Java环境配置</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 jdk8</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install openjdk-8-jdk</span><br><span class="line"><span class="comment"># 编译源码的时候可能需要切换jdk</span></span><br><span class="line">sudo update-alternatives --config java</span><br><span class="line">sudo update-alternatives --config javac</span><br><span class="line"><span class="comment"># 如果没有将jdk路径添加进系统，需要先添加。</span></span><br><span class="line">sudo update-alternatives --install /usr/bin/java java ~/tools/java/jdk1.6.0_45/bin/java 700</span><br><span class="line">sudo update-alternatives --install /usr/bin/javac javac ~/tools/java/jdk1.6.0_45/bin/javac 700</span><br><span class="line">sudo update-alternatives --install /usr/bin/jar jar ~/tools/java/jdk1.6.0_45/bin/jar 700</span><br><span class="line"><span class="comment"># 这里的700是优先级， ~/tools/java/jdk1.6.0_45/bin是自己安装jdk的目录</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>配置ccache</li>
</ol>
<p style="text-indent:2em">ccache是一个编译cache系统，可以加快c/c++代码编译的速度(编译过一次之后)。有ccache的情况下，整个android编译的时间从超过1个小时下降到约半个小时。配置方法见android网站说明：https://source.android.com/source/initializing.html#optimizing-a-build-environment
    上述配置对kernel代码无效。kernel编译使用ccache请参考下述文章：https://apuroth.gitbooks.io/android-study/content/20160701.html</p>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译安卓P、Q启用ccache方法：</span></span><br><span class="line">sudo apt install ccache</span><br><span class="line">vim ~/.bashrc</span><br><span class="line"><span class="built_in">export</span> USE_CCACHE=1</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br><span class="line">ccache -M 100G</span><br><span class="line"><span class="comment"># 缓存数据默认保持在~/.ccache，上一行指令可以自己设置缓存的最大值。</span></span><br></pre></td></tr></table></figure>

<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><h4 id="源码整编"><a href="#源码整编" class="headerlink" title="源码整编"></a>源码整编</h4><p style="text-indent:2em">整编就是编译整个Android源码，整编主要有三个步骤，下面分别就行介绍。


</p><p><img src="/.top//Android10.0%E7%BC%96%E8%AF%91%E6%AD%A5%E9%AA%A4%E5%A6%82%E4%B8%8B%E5%9B%BE%E6%89%80%E7%A4%BA.jpg" alt="Android10.0编译步骤如下图所示"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> build/envsetup.sh   <span class="comment"># 初始化编译环境</span></span><br><span class="line">lunch aosp_arm-eng         <span class="comment"># 或者 m PRODUCT-aosp_x86_64-eng，Android 10.0不一定需要lunch命令</span></span><br><span class="line">make -j8                   <span class="comment"># 编译模块也可以直接用 m libart</span></span><br></pre></td></tr></table></figure>

<ol>
<li><h5 id="初始化环境"><a href="#初始化环境" class="headerlink" title="初始化环境"></a>初始化环境</h5></li>
</ol>
<p style="text-indent:2em">在AOSP的根目录，输入如下的命令,使用build目录中的envsetup.sh脚本初始化环境，这个脚本会引入其他的执行脚本。</p>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> build/envsetup.sh</span><br><span class="line">// 编译前删除build文件夹out</span><br><span class="line">make clobber</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><h5 id="选择编译目标"><a href="#选择编译目标" class="headerlink" title="选择编译目标"></a>选择编译目标</h5></li>
</ol>
<p style="text-indent:2em">输入命令：</p>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lunch</span><br></pre></td></tr></table></figure>

<p style="text-indent:2em">lunch命令是envsetup.sh里定义的一个命令，用来让用户选择编译目标。会有以下信息输出：</p>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">You&#x27;re building on Linux</span><br><span class="line"></span><br><span class="line">Lunch menu... pick a combo:</span><br><span class="line">     1. aosp_arm-eng</span><br><span class="line">     2. aosp_arm64-eng</span><br><span class="line">     3. aosp_blueline-userdebug</span><br><span class="line">     4. aosp_blueline_car-userdebug</span><br><span class="line">     5. aosp_bonito-userdebug</span><br><span class="line">     6. aosp_bonito_car-userdebug</span><br><span class="line">     7. aosp_bramble-userdebug</span><br><span class="line">     8. aosp_car_arm-userdebug</span><br><span class="line">     9. aosp_car_arm64-userdebug</span><br><span class="line">     10. aosp_car_x86-userdebug</span><br><span class="line">     11. aosp_car_x86_64-userdebug</span><br><span class="line">     12. aosp_cf_arm64_auto-userdebug</span><br><span class="line">     13. aosp_cf_arm64_phone-userdebug</span><br><span class="line">     14. aosp_cf_x86_64_pc-userdebug</span><br><span class="line">     15. aosp_cf_x86_64_phone-userdebug</span><br><span class="line">     16. aosp_cf_x86_auto-userdebug</span><br><span class="line">     17. aosp_cf_x86_phone-userdebug</span><br><span class="line">     18. aosp_cf_x86_tv-userdebug</span><br><span class="line">     19. aosp_coral-userdebug</span><br><span class="line">     20. aosp_coral_car-userdebug</span><br><span class="line">     21. aosp_crosshatch-userdebug</span><br><span class="line">     22. aosp_crosshatch_car-userdebug</span><br><span class="line">     23. aosp_flame-userdebug</span><br><span class="line">     24. aosp_flame_car-userdebug</span><br><span class="line">     25. aosp_redfin-userdebug</span><br><span class="line">     26. aosp_sargo-userdebug</span><br><span class="line">     27. aosp_sunfish-userdebug</span><br><span class="line">     28. aosp_trout_arm64-userdebug</span><br><span class="line">     29. aosp_trout_x86-userdebug</span><br><span class="line">     30. aosp_x86-eng</span><br><span class="line">     31. aosp_x86_64-eng</span><br><span class="line">     32. arm_krait-eng</span><br><span class="line">     33. arm_v7_v8-eng</span><br><span class="line">     34. armv8-eng</span><br><span class="line">     35. armv8_cortex_a55-eng</span><br><span class="line">     36. armv8_kryo385-eng</span><br><span class="line">     37. beagle_x15-userdebug</span><br><span class="line">     38. beagle_x15_auto-userdebug</span><br><span class="line">     39. car_x86_64-userdebug</span><br><span class="line">     40. db845c-userdebug</span><br><span class="line">     41. fuchsia_arm64-eng</span><br><span class="line">     42. fuchsia_x86_64-eng</span><br><span class="line">     43. hikey-userdebug</span><br><span class="line">     44. hikey64_only-userdebug</span><br><span class="line">     45. hikey960-userdebug</span><br><span class="line">     46. hikey960_tv-userdebug</span><br><span class="line">     47. hikey_tv-userdebug</span><br><span class="line">     48. pixel3_mainline-userdebug</span><br><span class="line">     49. poplar-eng</span><br><span class="line">     50. poplar-user</span><br><span class="line">     51. poplar-userdebug</span><br><span class="line">     52. qemu_trusty_arm64-userdebug</span><br><span class="line">     53. silvermont-eng</span><br><span class="line">     54. uml-userdebug</span><br><span class="line">     55. yukawa-userdebug</span><br><span class="line">     56. yukawa_sei510-userdebug</span><br><span class="line"></span><br><span class="line">Which would you like? [aosp_arm-eng]</span><br></pre></td></tr></table></figure>

<p style="text-indent:2em">意思就是要你选择编译目标的格式，编译目标的格式组成为BUILD-BUILDTYPE，比如 aosp_arm-eng 的BUILD为aosp_arm，BUILDTYPE为eng。其中BUILD表示编译出的镜像可以运行在什么环境，aosp代表Android开源项目，arm表示系统是运行在arm架构的处理器上。
    更多参考<a target="_blank" rel="noopener" href="https://source.android.google.cn/source/running.html#selecting-device-build">官方文档</a>。BUILDTYPE 指的是编译类型，有以下三种：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- user：用来正式发布到市场的版本，权限受限，如没有 root 权限，不能 dedug，adb默认处于停用状态。</span><br><span class="line">- userdebug：在user版本的基础上开放了 root 权限和 debug 权限，adb默认处于启用状态。一般用于调试真机。</span><br><span class="line">- eng：开发工程师的版本，拥有最大的权限(root等)，具有额外调试工具的开发配置。一般用于模拟器。</span><br></pre></td></tr></table></figure>

<p style="text-indent:2em">如果没有Nexus设备，只想编译完后运行在模拟器查看，那么BUILD可以选择aosp_x86，BUILDTYPE选择eng，Which would you like? [aosp_arm-eng] 后面直接输入对应序号30就可以了。也可以直接指定编译的目标或者序号(不同的系统版本，序号的对应会有差别，建议不要直接用序号）：


<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lunch aosp_x86-eng</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">lunch 30</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><h5 id="开始编译"><a href="#开始编译" class="headerlink" title="开始编译"></a>开始编译</h5></li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m -j12  2&gt;&amp;1 | tee build.log</span><br></pre></td></tr></table></figure>

</p><p style="text-indent:2em">通过-jN参数来设置编译的并行任务数，以提高编译速度，这里N值最好选在核数到2倍核数之间。编译成功后会在 out/target/product/generic_x86/目录生成了三个重要的镜像文件： system.img、userdata.img、ramdisk.img。大概介绍着三个镜像文件：</p>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- system.img：系统镜像,里面包含了Android系统主要的目录和文件,通过init.c进行解析并mount挂载到/system目录下。</span><br><span class="line">- userdata.img：用户镜像,是Android系统中存放用户数据的,通过init.c进行解析并mount挂载到/data目录下。</span><br><span class="line">- ramdisk.img：根文件系统镜像,包含一些启动Android系统的重要文件，比如init.rc。</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><h5 id="运行模拟器"><a href="#运行模拟器" class="headerlink" title="运行模拟器"></a>运行模拟器</h5></li>
</ol>
<p style="text-indent:2em">在编译完成之后,就可以通过以下命令运行Android虚拟机了，命令如下:
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果是在编译完后运行虚拟机，由于之前已经执行过source和lunch命令了，可以直接运行：</span></span><br><span class="line">emulator</span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="built_in">source</span> build/envsetup.sh</span><br><span class="line">lunch 30</span><br><span class="line">emulator</span><br></pre></td></tr></table></figure>

</p><h4 id="源码单编"><a href="#源码单编" class="headerlink" title="源码单编"></a>源码单编</h4><ul>
<li>make命令来进行编译</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> build/envsetup.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译 system.img</span></span><br><span class="line">lunch qssi-userdebug</span><br><span class="line">make &lt;system related images&gt;</span><br><span class="line"><span class="comment">#编译除system.img外的其他img</span></span><br><span class="line">lunch xx-userdebug</span><br><span class="line">make &lt;non-system images&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>高通提供的build.sh脚本进行编译</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译所有img，包括system和其它img</span></span><br><span class="line"><span class="built_in">source</span> build/envsetup.sh</span><br><span class="line">lunch XX-userdebug</span><br><span class="line">./build.sh dist -j32</span><br><span class="line"><span class="comment"># 编译system.img，产物在qssi目录下</span></span><br><span class="line"><span class="built_in">source</span> build/envsetup.sh</span><br><span class="line">lunch xx-userdebug</span><br><span class="line">./build.sh dist qssi_only -j32</span><br><span class="line"><span class="comment"># 编译super.img</span></span><br><span class="line"><span class="built_in">source</span> build/envsetup.sh</span><br><span class="line">lunch xx-userdebug</span><br><span class="line">./build.sh dist merge_only -j32</span><br><span class="line"><span class="comment"># 编译其它img，例如vendorimage，如果不指定会编译其它所有img，产物在XX目录下</span></span><br><span class="line"><span class="built_in">source</span> build/envsetup.sh</span><br><span class="line">lunch xx-userdebug</span><br><span class="line">./build.sh vendorimage dist target_only -j32</span><br></pre></td></tr></table></figure>

<ul>
<li><p>动态分区刷机的方法</p>
<p style="text-indent:2em">Q版本将system和vendor分区合并为super分区，无法通过adb reboot bootloader模式单独刷动态分区里面的img，例如system,vendor,product,odm，只能刷super.img和其他的。但是fastboot模式下可以单独刷动态分区里面的img，推荐进入fastboot模式刷机:</p></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">adb reboot fastboot</span><br><span class="line">fastboot getvar is-userspace</span><br><span class="line"><span class="comment"># is-userspace: yes</span></span><br><span class="line"><span class="comment"># Finished. Total time: 0.002s</span></span><br><span class="line">fastboot flash vendor vendor.img</span><br><span class="line">fastboot flash system system.img</span><br><span class="line">fastboot flash vbmeta vbmeta.img</span><br><span class="line">fastboot flash vbmeta_system vbmeta_system.img</span><br><span class="line"><span class="comment"># fastbootd是用户空间的代码，因为动态的逻辑分区只能在应用空间识别</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># fastboot刷机出现权限问题，需要将fastboot的所有者属性改成root</span></span><br><span class="line">sudo chown root:root fastboot</span><br><span class="line">sudo chmod +s fastboot</span><br></pre></td></tr></table></figure>

<ul>
<li><p>动态分区</p>
<p style="text-indent:2em">编译包中，我们找不到了对应的system,vendor等img文件，但是多了一个super.img，system,vendor,product,odm合并为super分区，这个就是动态分区了。Google在android Q中加入了动态分区，为了在OTA的时候能够灵活创建分区和修改分区大小，将system,vendor,odm,product合并成super分区，并在super分区上预留出一定量的free space，这样就可以动态调整这些分区的大小，解决了OTA的时候分区不足，以及调整分区的风险。</p>

<p><img src="/.top//%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA.png" alt="动态分区"></p>
<p><img src="/.top//super.img.layout.png" alt="super.img.layout"></p>
<p style="text-indent:2em">当ota升级之后，需要重新调整分区大小：</p>

<p><img src="/.top//ota%E5%8D%87%E7%BA%A7%E8%B0%83%E6%95%B4%E5%88%86%E5%8C%BA%E5%A4%A7%E5%B0%8F.png" alt="ota升级调整分区大小"></p>
</li>
<li><p>qssi(Qualcomm Single System Image)</p>
<p style="text-indent:2em">为了配合project treble，将系统与odm相关的解耦，需要单独编译system.img和其他img。而编译system image的时候需要lunch qssi，而编译其他分区的时候需要lunch target。引入qssi为解决Android碎片化问题，把system.img和vendor.img进一步拆分。</p></li>
</ul>
<p>Android源码工程默认不包含Linux Kernel代码，而是使用预先编译好的内核(/prebuilts/qemu-kernel/[cpu架构]/kernel-qemu文件)。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://luojianwei.top/2021/06/11/Android-Camera-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%8D%81%E4%BA%8C-%E6%89%8B%E6%9C%BA%E7%9B%B8%E6%9C%BA%E7%9A%84%E6%9C%AA%E6%9D%A5%E4%B8%8E%E5%8F%91%E5%B1%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="罗建伟的个人博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="罗建伟的个人主页">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/11/Android-Camera-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%8D%81%E4%BA%8C-%E6%89%8B%E6%9C%BA%E7%9B%B8%E6%9C%BA%E7%9A%84%E6%9C%AA%E6%9D%A5%E4%B8%8E%E5%8F%91%E5%B1%95/" class="post-title-link" itemprop="url">Android Camera 体系结构十二 手机相机的未来与发展</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-06-11 15:07:58 / 修改时间：15:08:28" itemprop="dateCreated datePublished" datetime="2021-06-11T15:07:58+08:00">2021-06-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Camera/" itemprop="url" rel="index"><span itemprop="name">Camera</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p style="text-indent:2em">Android相机发展至今，通过开发者对框架的不断优化，算法人员对图像处理算法的不断提升，硬件工程师对硬件性能地不断调教，换来了在某些领域完全可以媲美专业相机的成像效果，这些成绩是有目共睹的，但是我们不能仅仅着眼于过去，试着将眼光放得长远些，如何将Android相机推向更高的维度，使其成为手机相机的王者，想必这是每一个热衷于技术的开发者都需要反复思考的问题，当然就我个人而言，对于它的未来，有着我自己的思考。</p>

<p style="text-indent:2em">Android相机，首先是基于Android系统，所以对于系统端的优化，我相信Google依然会不断的进行完善，特别地，谷歌一直奉行着接口与实现相分离的设计原则， 这就将很多的实现让渡给各自有实现需求的开发者，所以其实我们有很大的创作空间，比如App部分，通过设计良好的业务框架，让整个相机应用在一个高效且稳定的框架中运行，处理来自用户需求，下发图像需求至相机框架中。又比如对于Camera Hal的实现，其实这部分高通做的已经相当完备，从QCamera&MM-Camera架构到而今的CamX-CHI，都是在为上层提供更好地相机而努力着，但是框架谈不上完美，只能是比较符合当下实际情况，针对CamX-CHI而言，存在着内存占用过大以及CPU负载较高的问题，这些也是我们作为开发者所需要去攻克的难题。</p>

<p style="text-indent:2em">麻雀虽小，五脏俱全，Android相机的小体积中俨然具备着一个完整的相机硬件体系，从光圈到透镜组，再到感光器件最后到后期的图像处理模块，每一个器件都承担着自己特有的使命。对于整套硬件体系而言，对于每一个器件的一个小小的提升都有可能使其在一系列竞争者中脱颖而出，比如某品牌的一亿像素，由于机身厚度的限制，大尺寸的CMOS会给透镜组乃至后期的算法处理带来不小的压力。</p>

<p style="text-indent:2em">一张完美的图像，仅仅依靠前期的成像系统是远远不够的，就像当我们看见一副美景时，心中所呈现的并不是单单眼前的景色而已，我们所独有的人生阅历会在我们心中不经意地给其铺上一层独特的滤镜，赋予其独特的意义，而对于相机系统而言，算法便是其给图像铺上灵魂滤镜的关键因素，不同的算法可以赋予图像不同的属性，但是评价算法的好坏，经常会通过效果与效率两个方面来衡量，所以图像的更多意义，需要更多的算法来实现，而算法的更好更快处理便是其实现的目标，一个好的算法往往能够为平庸无奇的图像带来质的飞跃。</p>

<p style="text-indent:2em">而今的Android相机已经完全不局限于记录身边的美好，而是在创造属于每个人的美好，可以通过它来和相隔万里的亲人朋友进行视频通讯，可以编辑属于自己的独一无二的图像表情，可以让多个自己存在在同一个空间中，以及通过萌拍模式记录下自己的可爱瞬间等，这一切的一切都极大的扩展了Android相机的功能性和可玩性，所以针对新Feature的开发，势必是一个大的趋势，这也印证了一个道理，对于相机的开发，我们有时候不是在满足需求，而是在创造需求。</p>

<p style="text-indent:2em">最后，纵观Android历史，不难发现谷歌自始至终秉承着开源普惠大众的宗旨，从未停止过对Android系统的迭代优化，在整个Android相机系统架构中，不难发现接口与实现相分离的这一简单设计原则在其身上随处可见，这样既保证了整体架构的足够稳定，也实现了系统细节实现的多样性，同时也体现出了强大的灵活性，总的来讲，这样一套优秀的架构体系并且依托如今强大的硬件设备，加之全球开发者们在算法、新feature的不懈努力，我相信Android 相机会在以后的发展中一路高歌猛进，超越苹果成为手机相机领域的王者。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://luojianwei.top/2021/06/11/Android-Camera-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%8D%81%E4%B8%80-%E5%AE%89%E5%8D%93%E7%9B%B8%E6%9C%BA%E6%9E%B6%E6%9E%84%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="罗建伟的个人博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="罗建伟的个人主页">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/11/Android-Camera-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%8D%81%E4%B8%80-%E5%AE%89%E5%8D%93%E7%9B%B8%E6%9C%BA%E6%9E%B6%E6%9E%84%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">Android Camera 体系结构十一 安卓相机架构总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-06-11 15:06:53 / 修改时间：15:07:28" itemprop="dateCreated datePublished" datetime="2021-06-11T15:06:53+08:00">2021-06-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Camera/" itemprop="url" rel="index"><span itemprop="name">Camera</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p style="text-indent:2em">Android 相机体系庞大且复杂，在我刚开始接触到该框架的时候，如盲人摸象一般，一点一点地在代码的世界中探索，在很长的一段时间内，都只能局限于某一个特定的区域，而且在解决问题的过程中，虽然通过对代码的深入梳理，最终都会顺利解决难题，但是到最后依然缺乏一个对于整个框架的理解，正如管中窥豹一般，只见细节而无法把握全貌。但是进入现在的公司之后，通过与相机前辈的沟通，我发现框架思维能力尤为重要，针对整个框架结构需要做到掌控全局，这样在遇到问题的时候便可以迅速定位，此时再进行代码层面的深入研究，发现问题根源，进而达到最终解决问题的目的。</p>

<p style="text-indent:2em">Android相机体系随处可见接口与实现相分离的设计思想，而之前提及的对于体系结构的梳理正是按照其接口的逻辑定义来完成，再结合其接口具体实现，进而完善整个框架体系的代码地图的构建，而在本人六年多的相机开发过程中，经历了多次的Android 相机的框架调整，接口演变，接下来以个人经历为主线，简单为整个相机架构做一个总结。</p>

<p style="text-indent:2em">起初，首先接触到的相机框架部分便是驱动，那时接触的是高通MSM8953平台，该平台还是采用的QCamera & MM-Camera框架，底层驱动并没有负责复杂业务逻辑控制，而是主要用于控制上下电，以及数据流的开启以及停止等，并且依然使用的是vb2进行图像帧缓冲区的管理，但是现如今的7150，其驱动部分俨然发生了翻天覆地的变化，高通为了配合UMD的业务处理，为驱动设计了一套KMD的框架，包含了复杂的业务处理流程，并且数据的管理也摒弃了vb2，采用了新的管理手段，赋予了驱动更多的职能。</p>

<p style="text-indent:2em">之后由于工作需要，进一步将工作重心过渡到Camera HAL层，开发的平台依然是MSM8953平台上，当时采用还是QCamera & MM-Camera框架，在该平台上见证了HAL接口的演变，首先接触最多的便是HAL1接口，该接口使用起来比较简单，通过几个特定接口分别实现预览、拍照以及录像的功能，此时，谷歌已经意识到该接口具有一定的局限，所以自然而然地进行接口的升级，提出了HAL2接口，但是由于接口定义存在问题，所有很快谷歌便摒弃了该接口，迅速推出HAL3接口，并且一直沿用至今。HAL3接口相比于HAL1，优势明显，通过将所有的采集流程高度抽象为一个统一逻辑，所有的场景都可以通过这一统一逻辑进行扩展，使该接口具有很强的灵活性和扩展性，所以通过这几代HAL接口的演变，不难得出一个结论，那便是接口的定义需要高度抽象，而抽象的目的就是为了更好的灵活性和可扩展性，就单单这一点而言，HAL3接口可以说是成功的。</p>

<p style="text-indent:2em">在后续HAL层的开发过程中，也见证了HIDL接口的诞生，在进行Android 8.0系统的升级过程中，发现谷歌将Camera Hal Module从Camera Service 解耦出来，放入一个独立的进程Camera Provider中进行管理，而该进程负责向外暴露HIDL接口，对内完成对其的实现，并且开始针对system分区以及vendor分区进行了严格的权限控制，该目的显而易见，那边是将平台厂商的实现与谷歌Framework相分离，这样便可以进行快速的迭代升级。</p>

<p style="text-indent:2em">进入现在的公司之后，工作内容进一步扩大，涉及到了App部分，而这部分在之前也有所接触，但是并不深入，那个时候还是使用Camera Api v1接口，其定义和HAL1类似，但为了增加其灵活性和扩展性，之后谷歌提出了Camera Api v2接口，现在主要接触的便是该接口，通过简单的几个控制语句便可以实现图像的采集，使用起来比较简单，进一步降低了开发者的门槛，这也从侧面体现出了该接口定义的巧妙。同时，对于Camera Api v2的实现，是通过Camera Framework来完成的，而该层也有着一次不小的演变，刚开始Framework层并不是直接通过AIDL接口与Camera Service进行通信，而是通过一个JNI层来完成从Java到Native的转换，而Native部分作为客户端，保持对Service的通信。这种设计，很显然会比较臃肿，并且代码难以维护，所以之后由于AIDL接口的提出，谷歌直接将其加入到相机框架中，用于保持Framework与Service的通信，进而摈弃了JNI层，进一步减少了不必要的层级结构，保持了整个体系简洁性。</p>

<p style="text-indent:2em">整个相机体系，经历了多次的发展，最终形成了而今的框架结构，一路走来，不难发现都是对于接口的升级，而其升级主要是更新其逻辑定义，完善其具体实现。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://luojianwei.top/2021/06/11/Android-Camera-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B9%8B%E5%8D%81-%E7%9B%B8%E6%9C%BA%E7%A1%AC%E4%BB%B6%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="罗建伟的个人博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="罗建伟的个人主页">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/11/Android-Camera-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B9%8B%E5%8D%81-%E7%9B%B8%E6%9C%BA%E7%A1%AC%E4%BB%B6%E5%B1%82/" class="post-title-link" itemprop="url">Android Camera 体系结构之十 相机硬件层</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-06-11 15:05:20 / 修改时间：15:05:44" itemprop="dateCreated datePublished" datetime="2021-06-11T15:05:20+08:00">2021-06-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Camera/" itemprop="url" rel="index"><span itemprop="name">Camera</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p style="text-indent:2em">相机的硬件层，作为整个框架的最底层，通过硬件模块接收来自客观世界的真实光影效果，将其转换为计算机所熟知的数字信号，并按照一定的数据格式向上源源不断提供成稳定并成像效果优秀的图像数据，整个部分复杂且高效，可以说是，一个优秀的硬件基础，就好比为整个相机框架的地基，拥有一个好的地基，便使得建造一座摩天大厦成为可能，接下来我们来详细介绍下，这部分各个组件的基本情况。</p>

<h3 id="基本硬件结构"><a href="#基本硬件结构" class="headerlink" title="基本硬件结构"></a>基本硬件结构</h3><p style="text-indent:2em">而今的相机硬件系统纷繁复杂，但是如果仔细深入研究的话，你会发现，其实核心组件无外乎镜头、感光器、图像处理器三大件，其中镜头用来聚光，感光器件用于光电转换，而图像处理器用来加工处理图像数据，接下来我们就以这三个组件开始展开对于相机系统的世界的探索之旅。</p>

<p><img src="/.top//hardware.jpg" alt="hardware"></p>
<ol>
<li><h4 id="镜头焦距-Lens-Focus"><a href="#镜头焦距-Lens-Focus" class="headerlink" title="镜头焦距(Lens Focus)"></a>镜头焦距(Lens Focus)</h4></li>
</ol>
<p style="text-indent:2em">将时间的转盘向前波动一下，让我们回到各自的小学时代，那时候老师给我们都布置了一个家庭作业，任务是制作一个小孔成像的简单模型，这个简单模型便是我接触的最原始最简单的成像系统，但是那是我一直有一个疑问，成像为什么那么模糊，这个疑问在我接触到真正的相机之后才得以解开，原来一切都是光线惹的祸。</p>

<p style="text-indent:2em">根据小孔成像原理，小孔的一端是光源，另一端是成像平面，光经过小孔，入射到平面上，无数个光线都入射到这个平面上，便形成了光源的像，但是有一个问题，就是光线是按照发散路径向四周蔓延开来，光源某点所发出的某一束光线通过小孔后会到达成像平面的某一点上，但是很显然，该点也会接收来自另一个光源上的点所发出的另一束光线，这样就形成的光的干扰，进而影响了最终的成像效果。所以为了改善这个问题，镜头便被发明出来，而镜头其实就是我们日常生活中接触的凸透镜，其根本目的就是为了解决光线互相干扰的问题，其原理就是通过凸透镜的折射原理，将来自同一点的光线，重新汇聚至一点，从而大幅度提升了成像效果。而这里的重新汇聚的一点便是光源那点在透镜后的像点，而由于随着光源点的不断变换，其像点会相应的变化，所以我们常常将来自无限远处的光线，通过透镜之后汇聚而成的那个点称为该镜头的焦点，而焦点到透镜中心的距离，便称为焦距，一旦透镜制作完成，焦距便被确定下来。</p>

<ol start="2">
<li><h4 id="光圈快门"><a href="#光圈快门" class="headerlink" title="光圈快门"></a>光圈快门</h4></li>
</ol>
<p style="text-indent:2em">对于一个制作完成的镜头，无法随意调整镜头的直径，所以便在其中加入了一个叫做光圈的部件，该部件一般采用正多边形或者圆形的孔状光栅，通过调整光栅开合大小进而控制这个镜头的瞬时进光量，然而针对总的进光亮的控制仅仅依靠光圈也是不够的，需要再用到另一个叫做快门的部件，它主要决定着曝光的时长，最初的快门是通过调整镜头前的盖子的开关来进行实现，随着时代的进步，现在快门衍生出了多个实现方式，其中包括机械快门，它是作为一种只使用弹簧或者其他机械结构，不靠电力来驱动与控制速度的快门结构，电子快门，该快门结构通过马达和磁铁在电力驱动的作用下进行控制。电子断流快门，一种完全没有机械结构的快门结构，具有高快门速率和很快的影响捕捉频率，但是缺点是容易产生高光溢出现象。</p>

<p style="text-indent:2em">光圈控制着瞬时进光量，快门控制着曝光时间，通过两者的共同合作，完成了控制光线进入量的目的，进而进一步真实再现了场景的光影效果，避免了过度曝光的情况发生，极大的提升了整个提成像质量。</p>

<ol start="3">
<li><h4 id="对焦马达"><a href="#对焦马达" class="headerlink" title="对焦马达"></a>对焦马达</h4></li>
</ol>
<p style="text-indent:2em">正如之前所说，入射光线会在通过透镜之后以锥形路径汇聚到一点，该点叫做像点，之后再以锥形发散开去，而所有的相同距离发射的光线，都会汇聚到各自的像点上时，便形成了一个都是像点组成的一个平面，而这个平面一般叫做像平面，又由于这个平面是所有像点所汇聚而成的，所以该平面是成像清晰的，而现如今的对焦的本质便是通过移动透镜，使像平面与感光器件平面重合，从而在感光器件上形成清晰的像。一般来讲，对焦可以通过手动移动透镜完成，但是更一般地，是通过一个叫做对焦马达的器件来完成。除了手动调整镜头进而完成对焦操作外，现在比较主流的方式是通过自动移动透镜进而完成对焦动作，随着技术的不断发展，而今的对焦又发展出了自动对焦策略，其中包括了相位对焦和对比度对焦。其基本原理是前后调整镜头使像平面与感光器感光平面重合，从而形成清晰的成像效果。另外，针对更为复杂的相机系统，为了获得更加优秀的成像质量，一般都会采用多个透镜组合来实现，一来可以消除色差，二来可以通过马达调整透镜间的距离，来动态的修改整个透镜组的焦距，从而满足更加复杂场景下的成像需求。</p>

<ol start="4">
<li><h4 id="感光器-Sensor"><a href="#感光器-Sensor" class="headerlink" title="感光器(Sensor)"></a>感光器(Sensor)</h4></li>
</ol>
<p style="text-indent:2em">正如之前所讲，透镜的作用是为了汇聚光线，从而形成像平面，但是如何将这个所谓的像平面转换成计算机所熟知的图像信息呢？这就需要用到这里的感光器了，感光器并不是现代社会的专有发明，其实早在19世界初期的欧洲便有了这个概念，一位名叫尼埃普斯的法国人通过使用沥青加上薰衣草油，再以铅锡合金板作为片基，拍摄了从他家楼上看到的窗户外的场景，名叫《鸽子窝》的照片，而这里的沥青混以薰衣草油便是一种简单的感光物质，从这开始感光技术开始进入快速发展期，在1888年，美国柯达公司生产出了一种新型感光材料，柔软且可卷绕的胶卷，这是感光材料的一个质的飞跃，之后1969年在贝尔实验室，CCD数字感光器件被发明出来，将整个感光技术推入了数字时代，随后技术的不断革新，便于大规模批量生产的CMOS应运而生，将成像系统往更小更好的方向推进了一大步。随着CMOS的技术不断发展，优势明显的它渐渐取代了CCD，成为相机系统的主流感光器件。</p>

<ol start="5">
<li><h4 id="滤光片-IR-Filter"><a href="#滤光片-IR-Filter" class="headerlink" title="滤光片(IR Filter)"></a>滤光片(IR Filter)</h4></li>
</ol>
<p style="text-indent:2em">由于感光材料的特性所致，它会感受除了可见光波长范围内的光线，比如部分红外光，由于这部分红外光是不可见的，所以对于我们而言没有实际的用处(当然，这也不绝对，有的情况就是需要采集红外光的信息，比如夜视照相机)，并且可能会干扰之后的ISP的处理，所以往往需要使用一个用于过滤红外光，避免红外光线干扰，修正摄入的光线的滤片，一般分为干涉式的IR/AR-CUT(在低通滤波晶片上镀膜，利用干涉相消的原理)和吸收式的玻璃(利用光谱吸收的原理)。</p>

<ol start="6">
<li><h4 id="闪光灯-Flash"><a href="#闪光灯-Flash" class="headerlink" title="闪光灯(Flash)"></a>闪光灯(Flash)</h4></li>
</ol>
<p style="text-indent:2em">针对某些特殊场景，比如暗光环境下拍摄需求，此时由于光线本身较少，无法完成充分的感光操作，但是为了获取正常的拍摄需求，往往需要通过外部补光来作为额外的光照补偿，基于此，闪光灯便应运而生，对于手机而言，其主要分为氙气灯与LED灯两种，由于LED闪光灯具有功耗较低、体积较小的优势，作为手机闪光灯的主流选择。另外，现在很多手机采用了双色闪光灯的策略，双色闪光灯可以根据环境的需要调节两灯发光的强度，可以更为逼近自然光的效果，相比单闪光灯强度有所提升，另外色温也较普通双闪光灯要更为准确，总体来讲效果较好。</p>

<ol start="7">
<li><h4 id="图像处理器-ISP"><a href="#图像处理器-ISP" class="headerlink" title="图像处理器(ISP)"></a>图像处理器(ISP)</h4></li>
</ol>
<p style="text-indent:2em">一旦当感光器件完成光电转换之后，便会将数据给到图像处理器，而ISP第一步需要做的便是去掉暗电流噪声，何为暗电流噪声呢？这要从感光器件说起，针对CCD/CMOS而言，通常并不是全部都用于感光，有一部分是被专门遮挡住，用于采集在并未感光情况的暗电流情况，通过这种方式消除掉暗电流带来的噪声。</p>

<p style="text-indent:2em">对于镜头的各处的折射率不同的属性，会随着视场角的慢慢增大，能够通过镜头的斜光束慢慢减少，从而产生了图像中心亮度较边缘部分要高，这个现象在光学系统中叫做渐晕，很显然这种差异性会带成像的不自然，所以ISP接下来需要对于这种偏差进行修正，而修正的算法便是镜头阴影矫正，具体原理便是以图像中间亮度均匀的区域为中心，计算出个点由于衰减带来的图像变暗速度，从而计算出RGB三通道的补偿因子，根据这些补偿因子来对图像进行修正。</p>

<p style="text-indent:2em">随后，由于感光器件针对光线都是采用红、绿、蓝三基色进行分别采集而成的，所以数据一般会呈现出类似马赛克的排布效果，此时便需要完成去马赛克处理，基本原理便是通过一定的插值算法，通过附近的颜色分量猜测该像素所缺失的颜色分量，力争还原每一个像素的真实颜色效果，从而形成一个颜色真实的图像数据，而此时的数据格式便是RAW数据格式，即最原始的图像数据。</p>

<p style="text-indent:2em">当感光器进行光电转换的过程中，每一个环节都会产生一定的偏差，而这个偏差到最后便会以噪声的方式表现出来，所以接下来需要对于这个无关信息–噪声进行一定的降噪处理，当前主要采用了非线性去噪算法，比如双边滤波器，在采样时不仅考虑了像素在空间距离上的关系，同时还加入了像素间的相似程度考虑，从而保持了原始图像的大体分块，对于边缘信息保持良好。</p>

<p style="text-indent:2em">进一步降低了噪声之后，ISP需要对于图像白平衡进行处理，由于不同场景下的外界色温的不同，需要按照一定的比例调整RGB分量的值，从而使得在感光器中，白色依然是呈现白色的效果。白平衡可以采用手动白平衡，通过手动调整三个颜色分量的比例关系，达到白平衡的目的，而更一般地采用了自动白平衡的处理，这里ISP就承担着自动白平衡的使命，通过对当前图像进行分析，得到各颜色分量的比例关系，进而调整其成像效果。</p>

<p style="text-indent:2em">调整好图像白平衡后，需要进一步地调整颜色误差，这里的误差主要由于滤光片各颜色块之间存在颜色渗透所导致，一般在Tunning过程中会利用相机模组拍摄的图像与标准图像相比较得到的一个矫正矩阵，ISP利用这个矩阵来对拍摄的图像进行图像颜色矫正，从而达到还原拍摄场景中真实颜色的目的。</p>

<p style="text-indent:2em">以上简单罗列了下，图像处理器的几个基本功能，虽然每个厂商所生产的ISP都不尽相同，但是基本都包括了以上几个步骤，由此可见，图像处理器是用来提升整个相机系统的成像效果的。</p>

<h3 id="手机相机简介"><a href="#手机相机简介" class="headerlink" title="手机相机简介"></a>手机相机简介</h3><p><img src="/.top//camera.jpg" alt="img"></p>
<p style="text-indent:2em">对于手机上的相机系统，受到尺寸以及功耗的限制，无法像专业相机那样，为了保证成像效果，可以的很方便地更换更大的镜头，加入更大尺寸的CCD/CMOS感光器件，可以放入更加强大的图像处理模块，所以留给手机的发挥空间并不是很大，但是即便如此，各大手机厂商依旧在有限的空间和续航能力下，将相机系统做到了在某些领域媲美专业相机的地步，接下来我们来简单介绍下这套小体积但具有大能量的相机系统。</p>

<p style="text-indent:2em">如图所示，手机的相机系统可以分为两个部分，一个是相机模组，一个是图像处理器ISP，相机模组是用来进行进行光电转换的，而图像处理器正如之前所介绍那样是用于图像处理的，接下来我们分别来看下，两者在手机端是如何运行的。</p>

<ol>
<li><h4 id="相机模组"><a href="#相机模组" class="headerlink" title="相机模组"></a>相机模组</h4></li>
</ol>
<p style="text-indent:2em">由于受到体积的限制，手机相机模组往往做得十分精致小巧，里面主要包括了镜头、对焦马达、滤光片以及感光器(Sensor)。</p>

<p style="text-indent:2em">一般为了消除色差都会采用多个透镜的组合，手机中的镜头也不例外，其材质多是玻璃和塑料的组合，对于塑料镜头而言，成本较低，适合用于低端产品中的相机系统，而玻璃一般成像质量较高，但是成本也稍高于塑料镜头，所以往往用于一些追求成像质量的手机中，同时其中，镜头主要存在以下几个参数：</p>

<ul>
<li>视场角FOV，该参数表明了通过镜头可以成像多大范围的场景，一般FOV越大就越能看到大范围的景物，但是有可能会带来严重的畸变，通常使用后期的畸变矫正算法来修正大FOV所带来的畸变。</li>
<li>焦距F ，规定所有平行于透镜主轴的光线汇聚到的那点叫做焦点，而焦点到透镜中心的距离便是这里的焦距，一般焦距越大，镜头的FOV也就越小。而越短的焦距，往往FOV越大。</li>
<li>光圈值f，通过镜头焦距与实际光圈的直径比值来指定，该值越小，说明进光量也就越大，手机镜头一般采用f/2.0的固定光圈。</li>
</ul>
<p style="text-indent:2em">紧接着是对焦马达，这部分在手机中主要采用的是音圈马达(VCM)，而为了方便调整镜头，一般会将整个镜头集成在马达模组中，主板通过I2C总线传输指令，进而驱动马达的移动调整镜头达到对焦或者变焦的目的，这里我们简单介绍下音圈马达。**音圈马达**在电子学中被称为音圈电机，之所以被称为音圈，是因为其实现原理与扬声器类似，都是在一个永久磁场内部，通过改变马达内线圈的直流电流大小，来控制弹簧片的拉升位置，进而带动镜头上下运动，达到对焦或者变焦的目的，由于具有着高灵敏度与高精度的特点，使之成为手机的主流对焦组件。在手机端，对于音圈马达的使用一般分为两种模式，一种是变焦，一种是对焦，两者原理和目的都不一样。</p>

<ul>
<li>变焦: 通过马达调整镜头组中某一个透镜的移动，进而改变整个镜头的焦距，引起视场角的变化，从而实现对于景物的放大缩小的目的，这种方式便是我们常说的光学变焦，这种变焦手段的优点是在放大景物的过程中，不会损失图像细节，但是缺点也很明显，受到体积的限制，无法进行大范围的光学变焦，所以手机厂商一般采用光学与数字变焦的组合方式，达到高范围的变焦目的。</li>
<li>对焦: 通过音圈马达直接前后移动整个镜头，使物体的像平面与感光器的感光平面重合，进而得到一幅清晰的图像，这种方式正是对焦的过程。其目的是为了获得清晰的图像。</li>
</ul>
<p style="text-indent:2em">光线在经过了镜头之后，会首先进入到下一个组件–滤光片，该部分会针对光线做进一步处理，主要有两个目的：</p>

<ul>
<li>过滤红外线: 由于感光器会感受到部分不可见的红外线，进而干扰后面的图像处理效果，所以需要通过滤光片，将这部分红外线过滤掉，只让可见光透过。</li>
<li>修正光线: 光线通过透镜之后，并不都是平行垂直射向感光器的，还有很多并非直射的光线，很显然如果不对其进行拦截，会对感光器产生一定的干扰，所以滤光片利用石英的物理偏光特性，保留了直射的光线，反射掉斜射部份，避免影响旁边的感光点，进一步提升成像效果。</li>
</ul>
<p style="text-indent:2em">经过滤光片的过滤与修正，此时入射的光线具有一定的稳定性，此时就需要通过这个相机体系的核心感光器来进行光电转换了。</p>

<p style="text-indent:2em">手机端的感光器主要有CCD与CMOS，但是由于成本较高，体积较大，CCD在手机端已经用的不多了，CMOS成为了这个领域的主流感光器，手机端的CMOS依然采用了三层结构，微透镜/滤光片/感光层，具体定义如下：</p>

<ul>
<li>微透镜层主要用于扩展单个像素的受光面积。</li>
<li>滤光片采用的是Bayer模式，类似与RGB模式，都是采用RGB几个颜色分量来分别度量每一个像素的三通道的灰度值，但是基于人眼对于绿色更为敏感的基本规律，Bayer模式进一步强调了绿色分量，从而将绿色分量分别定义了Gr以及Gb，用于更好地表达图像的色彩和亮度。</li>
<li>感光层，用于将光子转换成电子信号，在经过放大电路以及模数转换电路，将其转换成数字信号。</li>
<li>其感光层的核心便是一个个感光二极管，每一个二极管边上都包含了一个放大器和一个数模转换电路。由于每一个感光元件都有一个放大器，虽然在一定程度上加快的速度的读取，但是却无法保证每一个放大器的放大效果一致，所以这种设计会带来可能的噪声。另外，由于CMOS在每一个二极管旁都加入了额外的硬件电路，势必会造成感光面积的缩小，所以这种设计会影响整体感光效果，这种设计被称为前照式，为了解决该问题，CMOS厂商推出了背照式设计，这种设计将感光像素与金属电极晶体管分别放置于感光片的两面，提高了像素占空比，增加了光线感应效率，增加了像素数量，改善了信噪比，极大的提升了成像效果。</li>
</ul>
<ol start="2">
<li><h4 id="图像处理器"><a href="#图像处理器" class="headerlink" title="图像处理器"></a>图像处理器</h4></li>
</ol>
<p style="text-indent:2em">手机端的图像处理器的实现流程基本和非手机端的相机系统中类似，对于高通平台的ISP，其中主要包括了诸如IFE/BPS/IPE/JPEG等硬件模块，他们分别担任了不通过图像处理任务，接下来我们一一简单介绍下：</p>

<ul>
<li>IFE(Image Front End)： Sensor输出的数据首先会到达IFE，该硬件模块会针对preview以及video去做一些颜色校正、下采样、去马赛克统计3A数据的处理。</li>
<li>BPS(Bayer Processing Segment): 该硬件模块主要用于拍照图像数据的坏点去除、相位对焦、 去马赛克，下采样、HDR处理以及Bayer的混合降噪处理。</li>
<li>IPE(Image Processing Engine): 该硬件主要由NPS、PPS两部分组成，承担诸如硬件降噪（MFNR、MFSR）、图像的裁剪、降噪、颜色处理、细节增强等图像处理工作。</li>
<li>JPEG: 拍照数据的存储通过该硬件模块进行jpeg编码工作。</li>
</ul>
<ol start="3">
<li><h4 id="多摄相机系统"><a href="#多摄相机系统" class="headerlink" title="多摄相机系统"></a>多摄相机系统</h4></li>
</ol>
<p style="text-indent:2em">相对于专业相机而言，手机相机的受众并不了解太多专业的摄影学知识，但是这类群体具有一个明显不同于专业相机受众的特点，那就是比较关注相机的便携性和可玩性，其中便携性不用多说，整体手机相机的都是以小巧著称，但是可玩性方面，各大手机厂商也是煞费苦心，采用了很多策略来扩展了相机的可玩性，其中多摄便是一个比较典型的例子。</p>

<p style="text-indent:2em">早期的手机相机，一般都是单独的后摄走遍天下，其功能比较单一，之后随着时代的发展以及年轻用户日益增多，对于自拍的需求愈发强烈，其中对于该领域的技术也有所突破。所以手机厂商便顺势推出了双摄模式，在手机前面额外加入一个相机模组来主要用于自拍，其中还在ISP中创新性地加入了美颜算法，进而大幅提升了自拍图像效果。紧接着，手机厂商将多个模组集成到手机上，进而满足了多个场景的拍照需求。现如今的手机相机，往往采用了多个摄像模组，有专门的用于拍摄微缩景观的微距模组，也有专门拍摄广角场景的广角模组，也有为了满足特定需求开发的双摄系统，由于双摄技术的飞速发展，而今已经产生了很多中成熟的方案。</p>

<p style="text-indent:2em">双摄技术顾名思义，是采用了两个摄像头模组分别成像，并通过特定的算法处理，融合成一张图像，达到特定成像需求的目的。普遍地，现在双摄方案主要用于实现背景虚化、提升暗光/夜景条件下成像质量、光学变焦，接下来依次进行简单的介绍：</p>

<h5 id="背景虚化-RGB-RGB"><a href="#背景虚化-RGB-RGB" class="headerlink" title="背景虚化(RGB + RGB)"></a><strong>背景虚化(RGB + RGB)</strong></h5><p style="text-indent:2em">为了实现该目的，主要采用了两个RGB的相机模组，同时对景物进行成像，利用三角测量原理，计算出每个点的景深数据，依靠该系列数据，进行前景以及背景的分离，再通过虚化算法针对背景虚化处理，最终营造出背景虚化的成像效果。值得注意的是，这里由于三角测量的原理的限制，需要对两个相机模组进行标定，使得两者成像平面位于同一平面，并且保持像素对齐。</p>

<h5 id="暗光提升-RGB-MONO"><a href="#暗光提升-RGB-MONO" class="headerlink" title="暗光提升(RGB + MONO)"></a><strong>暗光提升(RGB + MONO)</strong></h5><p style="text-indent:2em">在较暗的环境中，往往拍摄出来的效果不尽如人意，所以手机厂商便采用了一个RGB和一个黑白相机模组(MONO)来提升暗光成像效果，具体原理是，由于黑白相机模组没有Bayer滤光片，所以在暗光条件下，可以获得更多的进光量，进而保存了更多的图像细节，再加之RGB相机模组的颜色份量的补充，这样就可以更好的保证了暗光下的成像质量，同样的由于需要对两个相机模组的成像进行融合，所以依然需要进行标定操作，使两个相机模组能够保持像素对齐。</p>

<h5 id="光学变焦-广角-长焦"><a href="#光学变焦-广角-长焦" class="headerlink" title="光学变焦(广角 + 长焦)"></a><strong>光学变焦(广角 + 长焦)</strong></h5><p style="text-indent:2em">光学变焦，正如之前介绍的，完全可以在对焦马达中通过调整单个透镜进行焦距变换，从而实现变焦的目的，但是有受到体积的限制，往往无法从单个相机模组中得到更大的变焦范围，所以手机厂商就提出采用两个具有不同焦距(广角和长焦)的相机模组，共同实现光学变焦的目的，其原理是通过广角模组呈现大范围的场景，通过长焦模组看到更远的场景，在拍照是模组切换以及优秀的融合算法实现了相对平滑的变焦操作。</p><br>

<p style="text-indent:2em">通过上面的介绍，我们可以看到一个相机系统是通过镜头、光圈快门、感光器以及图像处理器组成，而为了提高其成像质量，在发展过程中逐步加入了滤光片、对焦马达以及闪光灯等组件，同时为了将相机系统嵌入手机中，无法避免地对硬件进行了一定的裁剪，比如光圈往往摒弃了可调形式，采用了固定光圈，另外，由于体积以及续航限制，手机上主流感光器主要采用了CMOS，而对焦马达也由于体积限制，对焦范围也有所缩小。但是即便硬件受到不小的限制，通过这这几年图像处理芯片不断发展，以及算法的不断优化，手机相机系统其实正在逐步缩小与专业相机的差距，我相信在不久的将来成像效果手机相机完全可以媲美专业相机。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://luojianwei.top/2021/06/11/Android-Camera-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B9%8B%E4%B9%9D-%E7%9B%B8%E6%9C%BA%E9%A9%B1%E5%8A%A8%E5%B1%82%E2%80%93%E9%AB%98%E9%80%9AKMD%E6%A1%86%E6%9E%B6%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="罗建伟的个人博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="罗建伟的个人主页">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/11/Android-Camera-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B9%8B%E4%B9%9D-%E7%9B%B8%E6%9C%BA%E9%A9%B1%E5%8A%A8%E5%B1%82%E2%80%93%E9%AB%98%E9%80%9AKMD%E6%A1%86%E6%9E%B6%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">Android Camera 体系结构之九 相机驱动层–高通KMD框架详解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-06-11 15:03:20 / 修改时间：15:05:06" itemprop="dateCreated datePublished" datetime="2021-06-11T15:03:20+08:00">2021-06-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Camera/" itemprop="url" rel="index"><span itemprop="name">Camera</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><p style="text-indent:2em">利用了V4L2可扩展这一特性，高通在相机驱动部分实现了自有的一套KMD框架，该框架通过V4L2标准方法在系统中创建设备节点，将控制接口直接暴露给UMD CSL进行访问，而其内部主要定义了一系列核心模块，包括CRM(Camera Request Manager)，用于管理整个KMD的Session/Link的创建销毁以及Request的在子设备间的流转，该模块创建video0设备节点暴露关键接口给UMD，此外还包括了Sync模块，主要负责了UMD/KMD之间的数据同步与传输，创建video1设备节点暴露接口给UMD进行访问，除此之外，为了更精细化地控制一系列的硬件图像处理模块，包括ISP/IPE/Sensor等硬件模块，高通也分别为各自子模块创建了设备节点，进而暴露控制接口给UMD进行访问。</p>

<p style="text-indent:2em">其中主要目录如下：</p>

<ul>
<li><p>cam_core/： 关于KMD核心函数的实现都放在这，主要包括了subdev、node、context的一些诸如创建/注册/销毁等标准方法。</p>
</li>
<li><p>cam_req_mgr/: CRM的具体实现，用于创建v4l2_device，用于管理所有的子设备，同时生成video设备节点，暴露控制接口给UMD，主要包括了Session/Link的行为管理以及Request的同步与分发，此外，还创建了media_device，用于暴露枚举接口给UMD来轮询查找整个KMD的子设备。</p>
</li>
<li><p>cam_sync/: 该部分主要实现了用于保持与UMD的图像数据的同步相关业务逻辑，由于该模块的特殊性，高通直接为其创建了一个单独的video设备节点，暴露了用于同步的一些控制接口。</p>
</li>
<li><p>cam_utils/: 一些共有方法的实现，包括debug方法集等</p>
</li>
<li><p>cam_smmu/: 高通自己实现了一套smmu api，供KMD使用</p>
</li>
<li><p>cam_lrme/: 低分辨率运动估计模块的驱动实现</p>
</li>
<li><p>cam_fd/: 人脸识别的驱动程序</p>
</li>
<li><p>cam_isp/: isp的驱动程序</p>
</li>
<li><p>cam_jpeg/: 编码器，可以通过该驱动完成jpeg的编码工作</p>
</li>
<li><p>cam_cdm/: camera data mover，数据移动器的驱动实现，主要用于解析由CSL传入的命令信息，其中包括了寄存器的设置以及图像数据的处理等。</p>
</li>
<li><p>cam_cpas/: 该模块主要用于CSL获取camera 平台驱动信息，IPE/BPS电源控制等</p>
</li>
<li><p>cam_icp/: image control processor ，图像处理控制器驱动实现</p>
</li>
<li><p>cam_hyp_intf/: Hypervisor 模块接口驱动程序实现</p>
</li>
<li><p>cam_sensor_module/: 类传感器的系列硬件模块</p>
</li>
<li><ul>
<li>cam_actuator/: 对焦马达的驱动实现</li>
<li>cam_cci/: 实现了用于通讯的CCI接口，其中包括了I2C以及gpio的实现</li>
<li>cam_csiphy: 基于MIPI CSI接口的物理层驱动，用于传输图像数据</li>
<li>cam_sensor_io: 使用cam_cci，向上实现了控制sensor的IO接口</li>
<li>cam_sensor: sensor 的驱动实现</li>
<li>cam_sensor_util: sensor相关的公有方法的实现</li>
<li>cam_eeprom: eeprom设备的驱动实现</li>
<li>cam_ois: 光学防抖设备的驱动实现</li>
<li>cam_flash: 闪光灯设备的驱动实现</li>
</ul>
</li>
</ul>
<h3 id="核心模块解析"><a href="#核心模块解析" class="headerlink" title="核心模块解析"></a>核心模块解析</h3><p style="text-indent:2em">正如之前介绍的那样，整个框架主要由三个部分组成，CRM/Camera Sync以及子模块，接下来我们以下图为例简单讲解下各自的关系：</p>

<p><img src="/.top//sub.dev.jpg" alt="sub.dev"></p>
<p style="text-indent:2em">在系统初始化时，CRM内部会创建一个v4l2_device结构体，用于管理所有的子设备，与此同时每一个子设备在注册的时候都会创建各自的v4l2_subdev挂载到该v4l2_device上面。此外，CRM会创建一个video0设备节点提供关键接口给CSL来进行访问，而每个子设备也会在系统中生成各自的v4l2-sbudev设备节点，提供接口给CSL进行更为精细化的控制。而其中的Cam Sync在初始化的过程中，也创建了一个v4l2_device设备，并且生成了video1节点给CSL进行控制。这个框架主要就是围绕这三个部分进行的，CRM用于管理Session/Link的创建，控制Request在各个子设备中的流转，子设备受CSL控制进行配置以及图像处理工作，而一旦图像处理完成便会将结果发送至Cam Sync模块，进上传至CSL中。</p>

<h4 id="CRM-Camera-Request-Manager"><a href="#CRM-Camera-Request-Manager" class="headerlink" title="CRM(Camera Request Manager)"></a>CRM(Camera Request Manager)</h4><p style="text-indent:2em">该模块本质上是一个软件模块，主要做了以下几个事情：</p>

<ul>
<li>接收来自CSL的Session/Link/Request请求，并且维护其在内核的状态。</li>
<li>在不同pipeline delay的子模块间，同步每一个Request状态，并按照需要发送给每一个子设备。</li>
<li>如果出现错误，负责上传至CSL。</li>
<li>负责针对实时子模块的flush操作。</li>
</ul>
<p style="text-indent:2em">其中针对Session/Link/Request的请求便是通过之前创建的video设备节点将接口暴露给CSL，一旦接收到命令便开始进行处理，而命令主要有以下几个：</p>

<ul>
<li>CAM_REQ_MGR_CREATE_SESSION/CAM_REQ_MGR_DESTROY_SESSION： 分别表示了Session的创建和销毁，该Session保持着与CamX-CHI的一一对应关系。</li>
<li>CAM_REQ_MGR_LINK/CAM_REQ_MGR_UNLINK： 分别表示了Link的创建和销毁动作，每一个Session可以包含多条Link，而每一个Link都连接着此次图像采集过程中所需要的子设备，CRM也是通过该Link来管理Request同步与分发的操作。</li>
<li>CAM_REQ_MGR_SCHED_REQ：一旦CSL开始下发Request的时候，便可以通过该命令告知KMD，而在KMD中，CRM会将此次Request存入Link中的in_q数组中，当子设备告知准备好了此次Request的处理后，便通知子设备进行配置并处理Request。</li>
<li>CAM_REQ_MGR_ALLOC_BUF/CAM_REQ_MGR_RELEASE_BUF: 图像缓冲区的申请与释放，CRM中使用cam_mem_table结构体来管理着申请的缓冲区。</li>
</ul>
<p style="text-indent:2em">一旦CRM接收了来自CSL的请求，便会在内部进行处理，而其中的一系列业务处理便会通过接下来的几个结构体来完成：</p>

<p style="text-indent:2em">首先在初始化过程中，会去创建一个cam_req_mgr_device。该结构体有以下几个主要的成员：</p>

<ul>
<li>video: 存储着对应的video_device。</li>
<li>v4l2_dev: 保存着初始化过程中创建的v4l2_device。</li>
<li>subdev_nodes_created: 标志着从属于v4l2_device的子设备是否都成功创建了设备节点。</li>
<li>cam_eventq： v4l2文件描述结构体，其中维护着event事件队列。</li>
</ul>
<p style="text-indent:2em">之后会去创建一个cam_req_mgr_core_device，该结构体比较简单主要用于维护一个Session链表，在CSL下发创建Session的动作后，会将创建好的Session放入该量表中，同时通过crm_lock保持着业务处理中的同步。</p>

<p style="text-indent:2em">一个Session可以包含很多条Link，其中变量num_links存储了Link数量，数组links存储着所有link，entry变量作为当前session的实体可以嵌入cam_req_mgr_core_device中的session链表中进行统一管理。</p>

<p style="text-indent:2em">在CSL下发CAM_REQ_MGR_LINK命令的时候，会去创建cam_req_mgr_core_link。</p>

<p style="text-indent:2em">该结构体比较复杂，接下来我们主要介绍下几个主要的变量：</p>

<ul>
<li>link_hdl：作为该Link的句柄，区别于其它Link。</li>
<li>num_devs： 表示了该条Link上连接了多少个子设备。</li>
<li>max_delay： 表示了从属于该Link上的所有子设备具有的最大的Pipeline delay值。</li>
<li>l_dev： 存储着所有从属于该Link上的子设备，后续对于子设备的控制都是通过该数组来进行的。</li>
<li>req： 该成员主要用于管理下发的request。</li>
<li>state: 标志着该Link的状态，而Link状态主要包括了CAM_CRM_LINK_STATE_AVAILABLE/CAM_CRM_LINK_STATE_IDLE/CAM_CRM_LINK_STATE_READY/CAM_CRM_LINK_STATE_ERR几种状态。</li>
</ul>
<p style="text-indent:2em">创建完Link之后，会将其存入一个存储cam_req_mgr_core_link的全局变量g_links中进行统一管理。</p>

<p style="text-indent:2em">而当下发CAM_REQ_MGR_SCHED_REQ命令的时候，会在内部进行解析，并且将其存入cam_req_mgr_core_link中的cam_req_mgr_req_data中等待后续的流转。</p>

<p style="text-indent:2em">其中in_q变量主要用于存储request，而l_tbl用于记录pipeline delay的相关信息，而apply_data数组用于存储所有的等待处理的request信息。</p>

<h4 id="Cam-Sync"><a href="#Cam-Sync" class="headerlink" title="Cam Sync"></a>Cam Sync</h4><p style="text-indent:2em">该模块本质上是一个软件模块，用于保持与UMD的图像数据的同步，主要利用了V4L2框架的event机制，由CSL进行事件的等待，一旦数据处理完毕，该模块便可以向上层发送事件，进而，通知CSL取出数据进行下一步处理，其中包括了几个主要ioctl的命令：</p>

<ul>
<li>CAM_SYNC_CREATE: 一旦CSL部分需要创建一个用于同步的实体的时候便下发该命令，而在Cam Sync中，会将传入的信息存入内部的sync_table_row数组中进行管理，并且将生成的sync_obj传入上层。</li>
<li>CAM_SYNC_DESTROY： 销毁用于同步的sync实体。</li>
<li>CAM_SYNC_REGISTER_PAYLOAD： 通过该命令将一些同步的回调方法注册到Cam Sync中，这样一但当数据处理完成，Cam Sync便可以由之前创建的sync_obj来找到相应的回调方法，进而调用该回调方法进行后续处理。</li>
<li>CAM_SYNC_DEREGISTER_PAYLOAD：释放之前注册的相关同步实体的信息，包括其回调方法。</li>
<li>CAM_SYNC_SIGNAL：该命令主要用于CamX-CHI中软件Node处理完数据之后，通知Cam Sync进行后续处理的目的。</li>
</ul>
<p style="text-indent:2em">其中包括了几个比较重要的结构体，首先在初始化过程中会去创建sync_device结构体，其主要的几个变量如下：</p>

<ul>
<li>vdev: 创建的video_device。</li>
<li>v4l2_dev: 创建的v4l2_device设备。</li>
<li>sync_table: 用于存储sync_table_row的数组。</li>
<li>cam_sync_eventq: v4l2设备描述符结构体，其中维护着event事件队列。</li>
</ul>
<p style="text-indent:2em">其中最重要的时sync_table中存储的sync_table_row结构体，它代表了整个对应于CSL中的sync object，其中比较重要的变量含义如下：</p>

<ul>
<li>sync_id：该sync object的唯一标识，同时该标识于CSL保持同步。</li>
<li>state: 代表了当前sync object的状态。</li>
<li>user_payload_list： 存储着该sync object所对应的来自UMD的payload，该payload在KMD中并没有被使用，仅仅存储与KMD中，一旦当前sync object被触发，便直接将其再次传入UMD中。</li>
</ul>
<h3 id="模块初始化"><a href="#模块初始化" class="headerlink" title="模块初始化"></a>模块初始化</h3><p style="text-indent:2em">在系统启动初期，整个相机驱动中的各个模块都开始进行加载了，接下来我们依次介绍下：</p>

<p style="text-indent:2em">首先是CRM的初始化，按照linux驱动模块的标准方法，会走到module_init宏声明的驱动结构体中的probe方法，这里是cam_req_mgr_probe方法，在该方法中主要做了以下几个事情：</p>

<ul>
<li>调用cam_v4l2_device_setup方法，创建并向系统注册用于管理所有子设备的v4l2_device。</li>
<li>调用cam_media_device_setup方法，创建并向系统注册media_device，并且创建了media设备节点，用于CSL枚举KMD中所有设备。</li>
<li>调用cam_req_mgr_util_init方法，其中初始化了一个cam_req_mgr_util_hdl_tbl，该结构体中存在一个handle数组，而每一个handle主要用于存储Session、Link以及各个子设备的相关信息，后期在整个图像采集的过程中，都是通过该结构体来找对应的操作实体，进而采取相应的动作。</li>
<li>调用cam_req_mgr_core_device_init方法，该方法中，会去创建并初始化一个cam_req_mgr_core_device结构体，作为全局变量g_crm_core_dev存在于整个框架中，而该结构体中主要包含了用于存储创建的Session的session_head链表，以及用于保护Session临界资源的crm_lock。</li>
</ul>
<p style="text-indent:2em">其次，是Cam Sync的初始化，整个流程最终会走到驱动结构体中的probe方法中，这里是cam_sync_probe方法，在该方法中主要做了以下几个事情：</p>

<ul>
<li>创建sync_dev结构体，该结构中通过一个sync_table_row数组来维护着所有的sync objects。</li>
<li>调用cam_sync_media_controller_init方法，用于创建media_deivce设备，并且创建了media设备节点，提供给CSL枚举子设备的能力。</li>
<li>调用v4l2_device_register方法，创建并像系统注册一个v4l2_device结构体，其中用于ioctl的方法集是指向的g_cam_sync_ioctl_ops，一旦CSL有创建/注册sync objects需求的时候，便会最终走到该方法中，从而实现相应的功能。</li>
<li>调用video_register_device方法，生成video1设备节点，暴露控制接口给CSL。</li>
<li>调用cam_sync_init_entity方法，将video1中的meida_entity中function字段赋值CAM_SYNC_DEVICE_TYPE，这样在UMD就可以通过相应的media节点枚举出该模块。</li>
</ul>
<p style="text-indent:2em">以上两个模块都是具有独立的video设备节点的，但是对于子设备而言，由于代表着相应的硬件设备，同时需要嵌入到整个框架中才能正常运行，所以高通将其抽象成了v4l2_subdev来进行管理，这里主要还是介绍两个比较有代表性的子模块，ISP以及Sensor。</p>

<p style="text-indent:2em">首先来看下ISP的初始化阶段，在其相应的probe方法cam_isp_dev_probe中做了如下几个事情：</p>

<ul>
<li>调用cam_subdev_probe方法，在该方法中，会去注册一个v4l2_subdev，并且将其挂载到CRM中的v4l2_device上，同时还创建了一个node，并且存入了v4l2_subdev中的token中，方便以后进行读取，另外，将方法集赋值为cam_subdev_ops，最后，创建了该v4l2_subdev内部的media_entity，并且为其function字段赋值为CAM_IFE_DEVICE_TYPE，这样也方便在枚举子设备时分辨出当前节点代表着isp模块。</li>
<li>调用cam_isp_hw_mgr_init方法，该方法用于初始化isp中的硬件模块。</li>
<li>调用cam_isp_context_init方法，该方法中会初始化node，在node内部创建一定数量的context，用于后期的状态维护，并且为每一个context都配置了状态机，以及子状态机来用于管理整个isp模块。</li>
</ul>
<p style="text-indent:2em">其次来看下Sensor模块的初始化，在其相应的probe方法cam_sensor_driver_i2c_probe中主要做了以下几个事情：</p>

<ul>
<li>调用cam_sensor_parse_dt方法获取dts中定义的硬件信息。</li>
<li>调用cam_sensor_init_subdev_params方法，该方法中会创建v4l2_subdev，然后挂载到CRM中的v4l2_device中，并且将sensor的私有方法集cam_sensor_internal_ops赋值给v4l2_subdev结构体中的ops，这样一旦操作相应的子设备节点，便最终会走到该方法集中，关于Sensor的一些操作便可以放到这个里面进行处理。最终将创建的v4l2_subdev中的media_entity中functon赋值为CAM_SENSOR_DEVICE_TYPE，方便CSL进行枚举Sensor设备。</li>
</ul>
<p style="text-indent:2em">通过上面的两个子设备的初始化代码梳理，不难发现，并没有进行设备节点的创建，那关于节点的创建动作发生在哪一个阶段呢？ 为了解决这个疑问我们不得不先介绍下linux两个宏定义，一个是module_init，另一个便是late_initcall，两者都是为了声明初始化函数，但是执行时间有一个先后顺序，而late_initcall一般在所有module_init定义的方法都运行完成之后才会被运行，而针对所有子设备的节点的创建便是在这里完成的，在该方法中主要做了以下工作：</p>

<ul>
<li>调用cam_dev_mgr_create_subdev_nodes方法，而在该方法中会去调用v4l2标准方法v4l2_device_register_subdev_nodes来统一创建挂载在CRM中v4l2_device下的子设备节点。</li>
</ul>
<p style="text-indent:2em">至此，整个KMD框架便初始化完成，现在便静静等待CSL下发请求。</p>

<h3 id="处理UMD-CSL请求"><a href="#处理UMD-CSL请求" class="headerlink" title="处理UMD CSL请求"></a>处理UMD CSL请求</h3><p style="text-indent:2em">整个KMD的初始化动作在linux内核启动的时候完成的，要稍早于CamX-CHI整个框架的初始化，所以在CamX-CHI进行初始化的时候，KMD框架的各个资源节点都已准备妥当，接下来我们就以CamX-CHI的初始化开始详细描述下整个KMD处理来自CSL请求的流程。</p>

<ol>
<li><h4 id="获取模块资源"><a href="#获取模块资源" class="headerlink" title="获取模块资源"></a>获取模块资源</h4></li>
</ol>
<p style="text-indent:2em">在CamX-CHI初始化的时候，并不知道内核驱动部分是个什么状态，所以需要打开所有的media设备节点来枚举查询每一个驱动模块。</p>

<p style="text-indent:2em">首先，打开media0，根据CAM_VNODE_DEVICE_TYPE枚举并找到KMD框架中的CRM模块，并调用标准open方法来打开该设备，该动作最终会调用到cam_req_mgr_open方法，该方法主要做了以下几个工作：</p>

<ul>
<li>调用v4l2_fh_open方法，打开v4l2文件。</li>
<li>调用cam_mem_mgr_init方法，初始化了内存管理模块，为之后的缓冲区的申请与释放做好准备。</li>
<li>更新CRM状态为CAM_MEM_MGR_INITIALIZED。</li>
</ul>
<p style="text-indent:2em">在打开video0之后，会另起一个线程用于监听video的事件，这样就建立了与底层的双向通讯，而在此之前，需要通过ioctl方法将CSL需要监听的事件下发到驱动层，其中包括以下几个事件：</p>

<ul>
<li>V4L_EVENT_CAM_REQ_MGR_SOF/V4L_EVENT_CAM_REQ_MGR_SOF_BOOT_TS： 一旦底层产生的SOF事件，便会向CSL发送该事件。</li>
<li>V4L_EVENT_CAM_REQ_MGR_ERROR： 一旦底层产生了错误，会向上抛出该事件。</li>
</ul>
<p style="text-indent:2em">一旦CSL获取了CRM模块信息成功之后，便开始枚举查找各个子模块了，其中会先去打开Sensor子设备，获取硬件信息，并且存入CSL中，然后再依次获取其它诸如IFE/IPE等硬件子模块并获取各自的信息，并存入CSL中，为之后的数据流转做好准备。</p>

<p style="text-indent:2em">以上动作都完成之后，便开始查询Cam Sync模块了，基本流程与CRM大致相同：</p>

<p style="text-indent:2em">调用open方法打开video1，该方法最终会调用内核部分的cam_sync_open方法，而该方法中会调用v4l2_fh_open方法，从而打开v4l2文件。</p>

<p style="text-indent:2em">调用ioctl方法，订阅针对CAM_SYNC_V4L_EVENT_ID_CB_TRIG事件的监听 ，而对于该事件，一般是在子模块处理数据完成之后，会触发Cam Sync发送该事件至上层。</p>

<ol start="2">
<li><h4 id="打开Session"><a href="#打开Session" class="headerlink" title="打开Session"></a>打开Session</h4></li>
</ol>
<p style="text-indent:2em">好了，到这里，整个CamX初始化过程对于底层的请求都已经完成了，一旦用户打开相机应用之后，经过层层调用最终会去打开Session，进而调用video0的相应的ioctl方法传入CAM_REQ_MGR_CREATE_SESSION命令开始在驱动层打开Session的操作，而在驱动部分，会调用到CRM中的cam_req_mgr_create_session方法，在该方法中，会去创建一个用于代表session的handle，并将其存入全局静态变量hdl_tbl中。紧接着会去初始化该session中的link，其中该session管理着两个link数组，一个是用于初始化的links_init数组，一个是用于运行起来之后使用的links数组，这里的会首先初始化所有的links_init中的link，在使用的时候，会从该数组去取出一个空闲的link放入links中进行管理。</p>

<ol start="3">
<li><h4 id="打开设备"><a href="#打开设备" class="headerlink" title="打开设备"></a>打开设备</h4></li>
</ol>
<p style="text-indent:2em">在打开Session之后，随着Pipeline的创建，CamX会通过调用CSL中的相应Node的ioctl方法，下发CAM_ACQUIRE_DEV命令，来依次打开底层硬件设备，这里我们还是以ISP为例进行分析：</p>

<ul>
<li>一旦CSL调用了ISP设备节点的ioctl并且下发了CAM_ACQUIRE_DEV命令，并会通过层层调用一直调到__cam_node_handle_acquire_dev方法，在该方法中会首先去在ISP对应的node中的存储空闲context的队列中获取一个context。</li>
<li>紧接着，调用了cam_context_handle_acquire_dev方法，来通过调用之前获取的context的对应的状态机方法集中的acquire_dev方法来打开isp设备，而在该方法中，会调用cam_create_device_hdl方法，将当前session handle以及isp操作方法集存入存入hdl_tbl中，之后crm会通过该方法集操作isp模块。之后会将当前isp context状态更新为CAM_CTX_ACQUIRED，并且初始化了用于管理request的active_req_list/wati_req_list/pending_req_list/pending_req_list/free_req_list链表，并且将初始化好req_list都挂载到free链表中。</li>
</ul>
<p style="text-indent:2em">除了ISP，会根据不同的图像采集需求，打开不同的子设备，基本流程差不多，都是通过下发CAM_ACQUIRE_DEV命令来完成的，这里我们便不进行赘述了。</p>

<ol start="4">
<li><h4 id="创建Link"><a href="#创建Link" class="headerlink" title="创建Link"></a>创建Link</h4></li>
</ol>
<p style="text-indent:2em">在打开所有的子设备之后，紧接着需要将它们链接起来形成一个拓扑结构，方便各个子模块的管理。而这个动作还是通过调用CRM对应的ioctl下发CAM_REQ_MGR_LINK命令来完成的，该动作会经过层层调用，一直调用到CRM中的cam_req_mgr_link方法，接下来我们具体介绍下该方法的主要动作：</p>

<ul>
<li>调用__cam_req_mgr_reserve_link方法，在该方法中，首先会去从当前Session中的links_init数组中取出一个空闲的link，将其存入links数组，并且初始化其中的用于管理所有的request的in_q队列。</li>
<li>调用cam_create_device_hdl，创建link对应的handle，并且存入hdl_tbl中。</li>
<li>调用__cam_req_mgr_create_subdevs方法，初始化用于存储处于当前Link中的所有子设备。</li>
<li>调用__cam_req_mgr_setup_link_info方法，该方法首先会去调用该link中的所有子设备的get_dev_info方法来获取设备信息，然后会去依次调用hdl_tbl中的链接在此Link上的所有子设备的setup_link方法，来连接子设备，同时也将CRM的一些回调方法通过该方式注入到子设备中，使其具有通知CRM的能力。</li>
<li>更新该Link状态为CAM_CRM_LINK_STATE_READY，并且创建了一个工作队列用于操作的异步处理。</li>
</ul>
<ol start="5">
<li><h4 id="开启数据流"><a href="#开启数据流" class="headerlink" title="开启数据流"></a>开启数据流</h4></li>
</ol>
<p style="text-indent:2em">一旦整个Link创建完成之后，便可以开启数据流了，该动作通过CSL控制每一个子设备来完成，这里还是以ISP为例进行分析：</p>

<p style="text-indent:2em">由于在CamX初始化过程中已经存有打开的ISP文件句柄，所有通过调用其iotcl方法下发CAM_START_DEV命令来通知底层ISP模块开始进行数据流程传输，该命令首先会走到node,然后通过node下发到context，然后调用当前context的状态机对应的start_dev方法，而在该方法中，会首先更新当前context状态为CAM_CTX_ACTIVATED，然后通过操作底层硬件管理模块开始数据流的处理。</p>

<p style="text-indent:2em">除了ISP，还有Sensor/FLash等模块也是需要开启数据流，为之后的Request的下发做好准备。</p>

<ol start="6">
<li><h4 id="下发Request"><a href="#下发Request" class="headerlink" title="下发Request"></a>下发Request</h4></li>
</ol>
<p style="text-indent:2em">一旦开启了整个数据处理流程，便可以接收Request请求了，而该动作依然还是通过CRM来完成，调用其ioctl方法，传入CRM_WORKQ_TASK_SCHED_REQ命令，该动作最终会到达内核CRM中的cam_req_mgr_schedule_request方法，而方法会将此次任务封装成task交由工作队列进行异步处理，而在工作队列中最终会调用其回调方法cam_req_mgr_process_sched_req，该方法主要做了如下工作：</p>

<ul>
<li>取出该request从属的link，并且将其中的in_q取出，找到一个空闲的slot，并将该slot便作为此次request在内核中的实体。</li>
<li>更新该slot的状态为CRM_SLOT_STATUS_REQ_ADDED，并且将link中的open_req_cnt计数加1。</li>
</ul>
<p style="text-indent:2em">从上面的梳理不难看出，下发Request的操作并不复杂，其中并没有一个实际的Request下发到子设备的动作，所以很自然地会产生一个疑问，没有下发Request的动作，那CRM是如何来驱动整个Request的流转的呢? 所以接下来我们来进一步介绍下，整个Request的流转机制。</p>

<ol start="7">
<li><h4 id="子设备处理数据"><a href="#子设备处理数据" class="headerlink" title="子设备处理数据"></a>子设备处理数据</h4></li>
</ol>
<p style="text-indent:2em">当CSL下发Request到KMD之后，便会进入到DRQ中进行流转，通过之前对于CamX的学习，想必大家应该已经熟悉了整个DRQ的运行机制，DRQ的每一个Node都会有一定依赖关系，一旦某个Node满足依赖关系之后，便会调用其ProcessRequest开始进行此次的Request处理，而该动作会将图像数据以及配置信息打包，通过调用ioctl方法下发CAM_CONFIG_DEV到具体的子设备节点来将配置写入KMD子设备中，而一旦子设备收到此次请求之后，会调用当前context的状态机所对应的config_dev方法，接下来我们具体介绍下其中的所作的动作：</p>

<ul>
<li>将此次配置信息包括图像数据放入硬件管理模块中，但是此时并不进行处理，等待处理指示。</li>
<li>将此次Request信息封装一下，通过调用之前setup_link传入的回调方法集中的add_req方法通知CRM，而在CRM中，会首先通过一系列的判断，如果条件满足了便将此次request对应的slot状态更新为CRM_REQ_STATE_READY，并将该request存入pending队列中。</li>
</ul>
<p style="text-indent:2em">由上面的分析，发现该过程中并没有进行实际的硬件配置或者处理，此时便需要等待SOF的事件，来驱动接下来的操作，而SOF事件是ISP来通知CRM的，具体流程如下：</p>

<ul>
<li>EPOCH中断产生，触发回调方法__cam_isp_ctx_notify_sof_in_activated_state，在该方法中会封装事件，并且通过调用CRM中传入的回调方法notify_trigger将事件发送至CRM中。</li>
<li>一旦CRM收取到SOF事件，便会去找到对应的满足要求的request，并且调用__cam_req_mgr_process_req方法通知相应的子设备进行配置。</li>
<li>最后ISP会将此次SOF事件通过V4L2 event机制发送至UMD，通知到CSL中。</li>
</ul>
<ol start="8">
<li><h4 id="数据操作完成"><a href="#数据操作完成" class="headerlink" title="数据操作完成"></a>数据操作完成</h4></li>
</ol>
<p style="text-indent:2em">当CamX中的各自Node完成了下发Request的操作之后，便会等待数据的处理完成，一旦完成便会触发buf_done中断，进而告知context，最终会调用cam_sync_signal方法来通知Cam Sync，而在Cam Sync中会通过子设备调用cam_sync_signal时传入的sync_id在sync_table_row找到相应的sync object，最终通过event机制，将此次处理完成的事件传入UMD CSL中，进而进行后续处理。</p>

<p style="text-indent:2em">等到最后一个Node处理完成之后，此次Request的处理便宣告完成。</p>

<p style="text-indent:2em">之前QCamera & MM-Camera架构采用的相机驱动比较简单，主要就承担了硬件的上下电以及读写寄存器的任务，并且控制方向都是从上到下，并且控制逻辑由UMD负责。但是随着时代的发展，相机硬件模块越发复杂，所以用于直接控制硬件的驱动层也需要承担更为复杂的控制任务，通过上面的分析，我们可以看到，高通重新设计了一套优秀的KMD框架，在其中加入了更多复杂的控制逻辑，以达到精细化控制底层硬件模块的目的，其中比较重要的是CRM对于子设备的横向控制，这样的好处很明显，降低了UMD控制驱动的难度，UMD只需要将请求通过V4L2框架中的设备节点下发至KMD中，之后便由KMD中的CRM来统一管理，适时地将请求下发给各个子设备，进而控制着底层硬件模块。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/home/page/5/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/home/">1</a><span class="space">&hellip;</span><a class="page-number" href="/home/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/home/page/7/">7</a><a class="extend next" rel="next" href="/home/page/7/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">罗建伟的个人博客</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
